
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>storage: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kubeflow/pipelines/backend/src/apiserver/storage/db.go (87.1%)</option>
				
				<option value="file1">github.com/kubeflow/pipelines/backend/src/apiserver/storage/db_fake.go (77.8%)</option>
				
				<option value="file2">github.com/kubeflow/pipelines/backend/src/apiserver/storage/db_status_store.go (72.3%)</option>
				
				<option value="file3">github.com/kubeflow/pipelines/backend/src/apiserver/storage/default_experiment_store.go (74.1%)</option>
				
				<option value="file4">github.com/kubeflow/pipelines/backend/src/apiserver/storage/experiment_store.go (71.8%)</option>
				
				<option value="file5">github.com/kubeflow/pipelines/backend/src/apiserver/storage/job_store.go (76.7%)</option>
				
				<option value="file6">github.com/kubeflow/pipelines/backend/src/apiserver/storage/minio_client.go (0.0%)</option>
				
				<option value="file7">github.com/kubeflow/pipelines/backend/src/apiserver/storage/minio_client_fake.go (86.7%)</option>
				
				<option value="file8">github.com/kubeflow/pipelines/backend/src/apiserver/storage/object_store.go (79.5%)</option>
				
				<option value="file9">github.com/kubeflow/pipelines/backend/src/apiserver/storage/object_store_fake.go (0.0%)</option>
				
				<option value="file10">github.com/kubeflow/pipelines/backend/src/apiserver/storage/pipeline_store.go (70.6%)</option>
				
				<option value="file11">github.com/kubeflow/pipelines/backend/src/apiserver/storage/resource_reference_store.go (75.9%)</option>
				
				<option value="file12">github.com/kubeflow/pipelines/backend/src/apiserver/storage/run_store.go (76.8%)</option>
				
				<option value="file13">github.com/kubeflow/pipelines/backend/src/apiserver/storage/sql_null_util.go (100.0%)</option>
				
				<option value="file14">github.com/kubeflow/pipelines/backend/src/apiserver/storage/task_store.go (59.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "bytes"
        "database/sql"
        "fmt"
        "strings"

        "github.com/VividCortex/mysqlerr"
        "github.com/go-sql-driver/mysql"
        sqlite3 "github.com/mattn/go-sqlite3"
)

// DB a struct wrapping plain sql library with SQL dialect, to solve any feature
// difference between MySQL, which is used in production, and Sqlite, which is used
// for unit testing.
type DB struct {
        *sql.DB
        SQLDialect
}

// NewDB creates a DB
func NewDB(db *sql.DB, dialect SQLDialect) *DB <span class="cov8" title="1">{
        return &amp;DB{db, dialect}
}</span>

// SQLDialect abstracts common sql queries which vary in different dialect.
// It is used to bridge the difference between mysql (production) and sqlite
// (test).
type SQLDialect interface {
        // GroupConcat builds query to group concatenate `expr` in each row and use `separator`
        // to join rows in a group.
        GroupConcat(expr string, separator string) string

        // Concat builds query to concatenete a list of `exprs` into a single string with
        // a separator in between.
        Concat(exprs []string, separator string) string

        // Check whether the error is a SQL duplicate entry error or not
        IsDuplicateError(err error) bool

        // Modifies the SELECT clause in query to return one that locks the selected
        // row for update.
        SelectForUpdate(query string) string
}

// MySQLDialect implements SQLDialect with mysql dialect implementation.
type MySQLDialect struct{}

func (d MySQLDialect) GroupConcat(expr string, separator string) string <span class="cov8" title="1">{
        var buffer bytes.Buffer
        buffer.WriteString("GROUP_CONCAT(")
        buffer.WriteString(expr)
        if separator != "" </span><span class="cov8" title="1">{
                buffer.WriteString(fmt.Sprintf(" SEPARATOR \"%s\"", separator))
        }</span>
        <span class="cov8" title="1">buffer.WriteString(")")
        return buffer.String()</span>
}

func (d MySQLDialect) Concat(exprs []string, separator string) string <span class="cov8" title="1">{
        separatorSQL := ","
        if separator != "" </span><span class="cov8" title="1">{
                separatorSQL = fmt.Sprintf(`,"%s",`, separator)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("CONCAT(%s)", strings.Join(exprs, separatorSQL))</span>
}

func (d MySQLDialect) IsDuplicateError(err error) bool <span class="cov0" title="0">{
        sqlError, ok := err.(*mysql.MySQLError)
        return ok &amp;&amp; sqlError.Number == mysqlerr.ER_DUP_ENTRY
}</span>

// SQLiteDialect implements SQLDialect with sqlite dialect implementation.
type SQLiteDialect struct{}

func (d SQLiteDialect) GroupConcat(expr string, separator string) string <span class="cov8" title="1">{
        var buffer bytes.Buffer
        buffer.WriteString("GROUP_CONCAT(")
        buffer.WriteString(expr)
        if separator != "" </span><span class="cov8" title="1">{
                buffer.WriteString(fmt.Sprintf(", \"%s\"", separator))
        }</span>
        <span class="cov8" title="1">buffer.WriteString(")")
        return buffer.String()</span>
}

func (d SQLiteDialect) Concat(exprs []string, separator string) string <span class="cov8" title="1">{
        separatorSQL := "||"
        if separator != "" </span><span class="cov8" title="1">{
                separatorSQL = fmt.Sprintf(`||"%s"||`, separator)
        }</span>
        <span class="cov8" title="1">return strings.Join(exprs, separatorSQL)</span>
}

func (d MySQLDialect) SelectForUpdate(query string) string <span class="cov0" title="0">{
        return query + " FOR UPDATE"
}</span>

func (d SQLiteDialect) SelectForUpdate(query string) string <span class="cov0" title="0">{
        return query
}</span>

func (d SQLiteDialect) IsDuplicateError(err error) bool <span class="cov8" title="1">{
        sqlError, ok := err.(sqlite3.Error)
        return ok &amp;&amp; sqlError.Code == sqlite3.ErrConstraint
}</span>

func NewMySQLDialect() MySQLDialect <span class="cov8" title="1">{
        return MySQLDialect{}
}</span>

func NewSQLiteDialect() SQLiteDialect <span class="cov8" title="1">{
        return SQLiteDialect{}
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "fmt"

        "github.com/golang/glog"
        "github.com/jinzhu/gorm"
        "github.com/kubeflow/pipelines/backend/src/apiserver/model"
        _ "github.com/mattn/go-sqlite3"
)

func NewFakeDb() (*DB, error) <span class="cov8" title="1">{
        // Initialize GORM
        db, err := gorm.Open("sqlite3", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not create the GORM database: %v", err)
        }</span>
        // Create tables
        <span class="cov8" title="1">db.AutoMigrate(
                &amp;model.Experiment{},
                &amp;model.Job{},
                &amp;model.Pipeline{},
                &amp;model.PipelineVersion{},
                &amp;model.ResourceReference{},
                &amp;model.RunDetail{},
                &amp;model.RunMetric{},
                &amp;model.Task{},
                &amp;model.DBStatus{},
                &amp;model.DefaultExperiment{})

        return NewDB(db.DB(), NewSQLiteDialect()), nil</span>
}

func NewFakeDbOrFatal() *DB <span class="cov8" title="1">{
        db, err := NewFakeDb()
        if err != nil </span><span class="cov0" title="0">{
                glog.Fatalf("The fake DB doesn't create successfully. Fail fast.")
        }</span>
        <span class="cov8" title="1">return db</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        sq "github.com/Masterminds/squirrel"
        "github.com/golang/glog"
        "github.com/kubeflow/pipelines/backend/src/common/util"
)

var (
        defaultDBStatus = sq.Eq{"HaveSamplesLoaded": false}
)

type DBStatusStoreInterface interface {
        HaveSamplesLoaded() (bool, error)
        MarkSampleLoaded() error
}

var (
        dbStatusStoreColumns = []string{
                "HaveSamplesLoaded",
        }
)

// Implementation of a DBStatusStoreInterface. This store read/write state of the database.
// For now we store status like whether sample is loaded.
type DBStatusStore struct {
        db *DB
}

func (s *DBStatusStore) InitializeDBStatusTable() error <span class="cov8" title="1">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to create a new transaction to initialize database status.")
        }</span>

        <span class="cov8" title="1">rows, err := tx.Query("SELECT * FROM db_statuses")
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to load database status.")
        }</span>
        <span class="cov8" title="1">next := rows.Next()
        rows.Close() // "rows" shouldn't be used after this point.

        // The table is not initialized
        if !next </span><span class="cov8" title="1">{
                sql, args, queryErr := sq.
                        Insert("db_statuses").
                        SetMap(defaultDBStatus).
                        ToSql()

                if queryErr != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return util.NewInternalServerError(queryErr, "Error creating query to initialize database status table.")
                }</span>

                <span class="cov8" title="1">_, err = tx.Exec(sql, args...)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return util.NewInternalServerError(err, "Error initializing the database status table.")
                }</span>
        }
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Error("Failed to commit transaction to initialize database status table")
                return util.NewInternalServerError(err, "Failed to initializing the database status table.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *DBStatusStore) HaveSamplesLoaded() (bool, error) <span class="cov8" title="1">{
        var haveSamplesLoaded bool
        sql, args, err := sq.Select(dbStatusStoreColumns...).From("db_statuses").ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return false, util.NewInternalServerError(err, "Error creating query to get load sample status.")
        }</span>
        <span class="cov8" title="1">rows, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return false, util.NewInternalServerError(err, "Error when getting load sample status")
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        if rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(&amp;haveSamplesLoaded)
                if err != nil </span><span class="cov0" title="0">{
                        return false, util.NewInternalServerError(err, "Error when scanning row to load sample status")
                }</span>
                <span class="cov8" title="1">return haveSamplesLoaded, nil</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (s *DBStatusStore) MarkSampleLoaded() error <span class="cov8" title="1">{
        sql, args, err := sq.
                Update("db_statuses").
                SetMap(sq.Eq{"HaveSamplesLoaded": true}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "Error creating query to mark samples as loaded.")
        }</span>
        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Error mark samples as loaded.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// factory function for database status store
func NewDBStatusStore(db *DB) *DBStatusStore <span class="cov8" title="1">{
        s := &amp;DBStatusStore{db: db}
        // Initialize database status table
        s.InitializeDBStatusTable()
        return s
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2019 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "database/sql"

        sq "github.com/Masterminds/squirrel"
        "github.com/golang/glog"
        "github.com/kubeflow/pipelines/backend/src/common/util"
)

var (
        defaultExperimentDBValue = sq.Eq{"DefaultExperimentId": ""}
)

type DefaultExperimentStoreInterface interface {
        GetDefaultExperimentId() (string, error)
        SetDefaultExperimentId(id string) error
}

// Implementation of a DefaultExperimentStoreInterface. This stores the default experiment's ID,
// which is created the first time the API server is initialized.
type DefaultExperimentStore struct {
        db *DB
}

func (s *DefaultExperimentStore) initializeDefaultExperimentTable() error <span class="cov8" title="1">{
        // First check that the table is in fact empty
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to create a new transaction to initialize default experiment table.")
        }</span>
        <span class="cov8" title="1">rows, err := tx.Query("SELECT * FROM default_experiments")
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to get default experiment.")
        }</span>
        <span class="cov8" title="1">next := rows.Next()
        rows.Close()

        // If the table is not initialized, then set the default value.
        if !next </span><span class="cov8" title="1">{
                sql, args, queryErr := sq.
                        Insert("default_experiments").
                        SetMap(defaultExperimentDBValue).
                        ToSql()

                if queryErr != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return util.NewInternalServerError(queryErr, "Error creating query to initialize default experiment table.")
                }</span>

                <span class="cov8" title="1">_, err = tx.Exec(sql, args...)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return util.NewInternalServerError(err, "Error initializing the default experiment table.")
                }</span>
        }
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Error("Failed to commit transaction to initialize default experiment table")
                return util.NewInternalServerError(err, "Failed to initializing the default experiment table.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *DefaultExperimentStore) SetDefaultExperimentId(id string) error <span class="cov8" title="1">{
        sql, args, err := sq.
                Update("default_experiments").
                SetMap(sq.Eq{"DefaultExperimentId": id}).
                Where(sq.Eq{"DefaultExperimentId": ""}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "Error creating query to set default experiment ID.")
        }</span>
        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Error setting default experiment ID.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *DefaultExperimentStore) GetDefaultExperimentId() (string, error) <span class="cov8" title="1">{
        var defaultExperimentId string
        sql, args, err := sq.Select("DefaultExperimentId").From("default_experiments").ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return "", util.NewInternalServerError(err, "Error creating query to get default experiment ID.")
        }</span>

        <span class="cov8" title="1">rows, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return "", util.NewInternalServerError(err, "Error when getting default experiment ID")
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        if rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(&amp;defaultExperimentId)
                if err != nil </span><span class="cov0" title="0">{
                        return "", util.NewInternalServerError(err, "Error when scanning row to find default experiment ID")
                }</span>
                <span class="cov8" title="1">return defaultExperimentId, nil</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

// Sets the default experiment ID stored in the DB to the empty string. This needs to happen if the
// experiment is deleted via the normal delete experiment API so that the server knows to create a
// new default.
// This is always done alongside the deletion of the actual experiment itself, so a transaction is
// needed as input.
// Update is used instead of delete so that we don't need to first check that the experiment ID is
// there.
func (s *DefaultExperimentStore) UnsetDefaultExperimentIdIfIdMatches(tx *sql.Tx, id string) error <span class="cov8" title="1">{
        sql, args, err := sq.
                Update("default_experiments").
                SetMap(sq.Eq{"DefaultExperimentId": ""}).
                Where(sq.Eq{"DefaultExperimentId": id}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "Failed to create command to clear default experiment with ID: %s", id)
        }</span>
        <span class="cov8" title="1">_, err = tx.Exec(sql, args...)

        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "Failed to clear default experiment with ID: %s", id)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// factory function for creating default experiment store
func NewDefaultExperimentStore(db *DB) *DefaultExperimentStore <span class="cov8" title="1">{
        s := &amp;DefaultExperimentStore{db: db}
        // Initialize default experiment table
        s.initializeDefaultExperimentTable()
        return s
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2018-2022 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "database/sql"

        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/golang/glog"
        api "github.com/kubeflow/pipelines/backend/api/v1beta1/go_client"
        "github.com/kubeflow/pipelines/backend/src/apiserver/list"
        "github.com/kubeflow/pipelines/backend/src/apiserver/model"
        "github.com/kubeflow/pipelines/backend/src/common/util"
)

type ExperimentStoreInterface interface {
        ListExperiments(filterContext *model.FilterContext, opts *list.Options) ([]*model.Experiment, int, string, error)
        GetExperiment(uuid string) (*model.Experiment, error)
        CreateExperiment(*model.Experiment) (*model.Experiment, error)
        DeleteExperiment(uuid string) error
        ArchiveExperiment(expId string) error
        UnarchiveExperiment(expId string) error
}

type ExperimentStore struct {
        db                     *DB
        time                   util.TimeInterface
        uuid                   util.UUIDGeneratorInterface
        resourceReferenceStore *ResourceReferenceStore
        defaultExperimentStore *DefaultExperimentStore
}

var (
        experimentColumns = []string{
                "UUID",
                "Name",
                "Description",
                "CreatedAtInSec",
                "Namespace",
                "StorageState",
        }
)

// Runs two SQL queries in a transaction to return a list of matching experiments, as well as their
// total_size. The total_size does not reflect the page size.
func (s *ExperimentStore) ListExperiments(filterContext *model.FilterContext, opts *list.Options) ([]*model.Experiment, int, string, error) <span class="cov8" title="1">{
        errorF := func(err error) ([]*model.Experiment, int, string, error) </span><span class="cov8" title="1">{
                return nil, 0, "", util.NewInternalServerError(err, "Failed to list experiments: %v", err)
        }</span>

        // SQL for getting the filtered and paginated rows
        <span class="cov8" title="1">sqlBuilder := sq.Select(experimentColumns...).From("experiments")
        if filterContext.ReferenceKey != nil &amp;&amp; filterContext.ReferenceKey.Type == model.NamespaceResourceType </span><span class="cov0" title="0">{
                sqlBuilder = sqlBuilder.Where(sq.Eq{"Namespace": filterContext.ReferenceKey.ID})
        }</span>
        <span class="cov8" title="1">sqlBuilder = opts.AddFilterToSelect(sqlBuilder)

        rowsSql, rowsArgs, err := opts.AddPaginationToSelect(sqlBuilder).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>

        // SQL for getting total size. This matches the query to get all the rows above, in order
        // to do the same filter, but counts instead of scanning the rows.
        <span class="cov8" title="1">sqlBuilder = sq.Select("count(*)").From("experiments")
        if filterContext.ReferenceKey != nil &amp;&amp; filterContext.ReferenceKey.Type == model.NamespaceResourceType </span><span class="cov0" title="0">{
                sqlBuilder = sqlBuilder.Where(sq.Eq{"Namespace": filterContext.ReferenceKey.ID})
        }</span>
        <span class="cov8" title="1">sizeSql, sizeArgs, err := opts.AddFilterToSelect(sqlBuilder).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>

        // Use a transaction to make sure we're returning the total_size of the same rows queried
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                glog.Errorf("Failed to start transaction to list jobs")
                return errorF(err)
        }</span>

        <span class="cov8" title="1">rows, err := tx.Query(rowsSql, rowsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">exps, err := s.scanRows(rows)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">rows.Close()

        sizeRow, err := tx.Query(sizeSql, sizeArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">total_size, err := list.ScanRowToTotalSize(sizeRow)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">sizeRow.Close()

        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("Failed to commit transaction to list experiments")
                return errorF(err)
        }</span>

        <span class="cov8" title="1">if len(exps) &lt;= opts.PageSize </span><span class="cov8" title="1">{
                return exps, total_size, "", nil
        }</span>

        <span class="cov8" title="1">npt, err := opts.NextPageToken(exps[opts.PageSize])
        return exps[:opts.PageSize], total_size, npt, err</span>
}

func (s *ExperimentStore) GetExperiment(uuid string) (*model.Experiment, error) <span class="cov8" title="1">{
        sql, args, err := sq.
                Select(experimentColumns...).
                From("experiments").
                Where(sq.Eq{"uuid": uuid}).
                Limit(1).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to get experiment: %v", err.Error())
        }</span>
        <span class="cov8" title="1">r, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "Failed to get experiment: %v", err.Error())
        }</span>
        <span class="cov8" title="1">defer r.Close()
        experiments, err := s.scanRows(r)

        if err != nil || len(experiments) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to get experiment: %v", err.Error())
        }</span>
        <span class="cov8" title="1">if len(experiments) == 0 </span><span class="cov8" title="1">{
                return nil, util.NewResourceNotFoundError("Experiment", fmt.Sprint(uuid))
        }</span>
        <span class="cov8" title="1">return experiments[0], nil</span>
}

func (s *ExperimentStore) scanRows(rows *sql.Rows) ([]*model.Experiment, error) <span class="cov8" title="1">{
        var experiments []*model.Experiment
        for rows.Next() </span><span class="cov8" title="1">{
                var uuid, name, description, namespace, storageState string
                var createdAtInSec int64
                err := rows.Scan(&amp;uuid, &amp;name, &amp;description, &amp;createdAtInSec, &amp;namespace, &amp;storageState)
                if err != nil </span><span class="cov0" title="0">{
                        return experiments, err
                }</span>
                <span class="cov8" title="1">experiment := &amp;model.Experiment{
                        UUID:           uuid,
                        Name:           name,
                        Description:    description,
                        CreatedAtInSec: createdAtInSec,
                        Namespace:      namespace,
                        StorageState:   storageState,
                }
                // Since storage state is a field added after initial KFP release, it is possible that existing experiments don't have this field and we use AVAILABLE in that case.
                if experiment.StorageState == "" </span><span class="cov0" title="0">{
                        experiment.StorageState = "AVAILABLE"
                }</span>
                <span class="cov8" title="1">experiments = append(experiments, experiment)</span>
        }
        <span class="cov8" title="1">return experiments, nil</span>
}

func (s *ExperimentStore) CreateExperiment(experiment *model.Experiment) (*model.Experiment, error) <span class="cov8" title="1">{
        newExperiment := *experiment
        now := s.time.Now().Unix()
        newExperiment.CreatedAtInSec = now
        id, err := s.uuid.NewRandom()
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "Failed to create an experiment id.")
        }</span>
        <span class="cov8" title="1">newExperiment.UUID = id.String()

        if newExperiment.StorageState == "" </span><span class="cov8" title="1">{
                // Default to available if not set.
                newExperiment.StorageState = "AVAILABLE"
        }</span> else<span class="cov0" title="0"> if newExperiment.StorageState != "AVAILABLE" &amp;&amp;
                newExperiment.StorageState != "ARCHIVED" </span><span class="cov0" title="0">{
                return nil, util.NewInvalidInputError("Invalid value for StorageState field: %q.", newExperiment.StorageState)
        }</span>

        <span class="cov8" title="1">sql, args, err := sq.
                Insert("experiments").
                SetMap(sq.Eq{
                        "UUID":           newExperiment.UUID,
                        "CreatedAtInSec": newExperiment.CreatedAtInSec,
                        "Name":           newExperiment.Name,
                        "Description":    newExperiment.Description,
                        "Namespace":      newExperiment.Namespace,
                        "StorageState":   newExperiment.StorageState,
                }).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to create query to insert experiment to experiment table: %v",
                        err.Error())
        }</span>
        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                if s.db.IsDuplicateError(err) </span><span class="cov8" title="1">{
                        return nil, util.NewAlreadyExistError(
                                "Failed to create a new experiment. The name %v already exists. Please specify a new name.", experiment.Name)
                }</span>
                <span class="cov8" title="1">return nil, util.NewInternalServerError(err, "Failed to add experiment to experiment table: %v",
                        err.Error())</span>
        }
        <span class="cov8" title="1">return &amp;newExperiment, nil</span>
}

func (s *ExperimentStore) DeleteExperiment(id string) error <span class="cov8" title="1">{
        experimentSql, experimentArgs, err := sq.Delete("experiments").Where(sq.Eq{"UUID": id}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to delete experiment: %s", id)
        }</span>
        // Use a transaction to make sure both experiment and its resource references are deleted.
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to create a new transaction to delete experiment.")
        }</span>
        <span class="cov8" title="1">_, err = tx.Exec(experimentSql, experimentArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to delete experiment %s from table", id)
        }</span>
        <span class="cov8" title="1">err = s.defaultExperimentStore.UnsetDefaultExperimentIdIfIdMatches(tx, id)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to clear default experiment ID for experiment %v ", id)
        }</span>
        <span class="cov8" title="1">err = s.resourceReferenceStore.DeleteResourceReferences(tx, id, model.RunResourceType)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to delete resource references from table for experiment %v ", id)
        }</span>
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "Failed to delete experiment %v and its resource references from table", id)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *ExperimentStore) ArchiveExperiment(expId string) error <span class="cov8" title="1">{
        // ArchiveExperiment results in
        // 1. The experiment getting archived
        // 2. All the runs in the experiment getting archived no matter what previous storage state they are in
        sql, args, err := sq.
                Update("experiments").
                SetMap(sq.Eq{
                        "StorageState": "ARCHIVED",
                }).
                Where(sq.Eq{"UUID": expId}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to archive experiment %s. error: '%v'", expId, err.Error())
        }</span>

        // TODO(jingzhang36): use inner join to replace nested query for better performance.
        <span class="cov8" title="1">filteredRunsSql, filteredRunsArgs, err := sq.Select("ResourceUUID").
                From("resource_references as rf").
                Where(sq.And{
                        sq.Eq{"rf.ResourceType": model.RunResourceType},
                        sq.Eq{"rf.ReferenceUUID": expId},
                        sq.Eq{"rf.ReferenceType": model.ExperimentResourceType}}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to filter the runs in an experiment %s. error: '%v'", expId, err.Error())
        }</span>
        <span class="cov8" title="1">updateRunsSql, updateRunsArgs, err := sq.
                Update("run_details").
                SetMap(sq.Eq{
                        "StorageState": api.Run_STORAGESTATE_ARCHIVED.String(),
                }).
                Where(fmt.Sprintf("UUID in (%s)", filteredRunsSql), filteredRunsArgs...).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to archive the runs in an experiment %s. error: '%v'", expId, err.Error())
        }</span>

        <span class="cov8" title="1">updateRunsWithExperimentUUIDSql, updateRunsWithExperimentUUIDArgs, err := sq.
                Update("run_details").
                SetMap(sq.Eq{
                        "StorageState": api.Run_STORAGESTATE_ARCHIVED.String(),
                }).
                Where(sq.Eq{"ExperimentUUID": expId}).
                Where(sq.NotEq{"StorageState": api.Run_STORAGESTATE_ARCHIVED.String()}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to archive the runs in an experiment %s. error: '%v'", expId, err.Error())
        }</span>

        // TODO(jingzhang36): use inner join to replace nested query for better performance.
        <span class="cov8" title="1">filteredJobsSql, filteredJobsArgs, err := sq.Select("ResourceUUID").
                From("resource_references as rf").
                Where(sq.And{
                        sq.Eq{"rf.ResourceType": model.JobResourceType},
                        sq.Eq{"rf.ReferenceUUID": expId},
                        sq.Eq{"rf.ReferenceType": model.ExperimentResourceType}}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to filter the jobs in an experiment %s. error: '%v'", expId, err.Error())
        }</span>
        <span class="cov8" title="1">now := s.time.Now().Unix()
        updateJobsSql, updateJobsArgs, err := sq.
                Update("jobs").
                SetMap(sq.Eq{
                        "Enabled":        false,
                        "UpdatedAtInSec": now}).
                Where(sq.Eq{"Enabled": true}).
                Where(fmt.Sprintf("UUID in (%s)", filteredJobsSql), filteredJobsArgs...).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to archive the jobs in an experiment %s. error: '%v'", expId, err.Error())
        }</span>

        // In a single transaction, we update experiments, run_details and jobs tables.
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to create a new transaction to archive an experiment.")
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err,
                        "Failed to archive experiment %s. error: '%v'", expId, err.Error())
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec(updateRunsSql, updateRunsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err,
                        "Failed to archive runs with experiment reference being %s. error: '%v'", expId, err.Error())
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec(updateRunsWithExperimentUUIDSql, updateRunsWithExperimentUUIDArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err,
                        "Failed to archive runs with ExperimentUUID being %s. error: '%v'", expId, err.Error())
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec(updateJobsSql, updateJobsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err,
                        "Failed to disable all jobs in an experiment %s. error: '%v'", expId, err.Error())
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to archive an experiment %s and its runs", expId)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ExperimentStore) UnarchiveExperiment(expId string) error <span class="cov8" title="1">{
        // UnarchiveExperiment results in
        // 1. The experiment getting unarchived
        // 2. All the archived runs and disabled jobs will stay archived
        sql, args, err := sq.
                Update("experiments").
                SetMap(sq.Eq{
                        "StorageState": "AVAILABLE",
                }).
                Where(sq.Eq{"UUID": expId}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to unarchive experiment %s. error: '%v'", expId, err.Error())
        }</span>

        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err,
                        "Failed to unarchive experiment %s. error: '%v'", expId, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// factory function for experiment store
func NewExperimentStore(db *DB, time util.TimeInterface, uuid util.UUIDGeneratorInterface) *ExperimentStore <span class="cov8" title="1">{
        return &amp;ExperimentStore{
                db:                     db,
                time:                   time,
                uuid:                   uuid,
                resourceReferenceStore: NewResourceReferenceStore(db),
                defaultExperimentStore: NewDefaultExperimentStore(db),
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2018-2022 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "database/sql"
        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/golang/glog"
        "github.com/kubeflow/pipelines/backend/src/apiserver/list"
        "github.com/kubeflow/pipelines/backend/src/apiserver/model"
        "github.com/kubeflow/pipelines/backend/src/common/util"
)

var jobColumns = []string{"UUID", "DisplayName", "Name", "Namespace", "ServiceAccount", "Description", "MaxConcurrency",
        "NoCatchup", "CreatedAtInSec", "UpdatedAtInSec", "Enabled", "CronScheduleStartTimeInSec", "CronScheduleEndTimeInSec",
        "Schedule", "PeriodicScheduleStartTimeInSec", "PeriodicScheduleEndTimeInSec", "IntervalSecond",
        "PipelineId", "PipelineName", "PipelineSpecManifest", "WorkflowSpecManifest", "Parameters", "Conditions",
        "RuntimeParameters", "PipelineRoot",
}

type JobStoreInterface interface {
        ListJobs(filterContext *model.FilterContext, opts *list.Options) ([]*model.Job, int, string, error)
        GetJob(id string) (*model.Job, error)
        CreateJob(*model.Job) (*model.Job, error)
        DeleteJob(id string) error
        EnableJob(id string, enabled bool) error
        UpdateJob(swf *util.ScheduledWorkflow) error
}

type JobStore struct {
        db                     *DB
        resourceReferenceStore *ResourceReferenceStore
        time                   util.TimeInterface
}

// Runs two SQL queries in a transaction to return a list of matching jobs, as well as their
// total_size. The total_size does not reflect the page size, but it does reflect the number of jobs
// matching the supplied filters and resource references.
func (s *JobStore) ListJobs(
        filterContext *model.FilterContext, opts *list.Options) ([]*model.Job, int, string, error) <span class="cov8" title="1">{
        errorF := func(err error) ([]*model.Job, int, string, error) </span><span class="cov8" title="1">{
                return nil, 0, "", util.NewInternalServerError(err, "Failed to list jobs: %v", err)
        }</span>

        <span class="cov8" title="1">rowsSql, rowsArgs, err := s.buildSelectJobsQuery(false, opts, filterContext)
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>

        <span class="cov8" title="1">sizeSql, sizeArgs, err := s.buildSelectJobsQuery(true, opts, filterContext)
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>

        // Use a transaction to make sure we're returning the total_size of the same rows queried
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                glog.Errorf("Failed to start transaction to list jobs")
                return errorF(err)
        }</span>

        <span class="cov8" title="1">rows, err := tx.Query(rowsSql, rowsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>
        <span class="cov8" title="1">jobs, err := s.scanRows(rows)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">rows.Close()

        sizeRow, err := tx.Query(sizeSql, sizeArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">total_size, err := list.ScanRowToTotalSize(sizeRow)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">sizeRow.Close()

        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("Failed to commit transaction to list jobs")
                return errorF(err)
        }</span>

        <span class="cov8" title="1">if len(jobs) &lt;= opts.PageSize </span><span class="cov8" title="1">{
                return jobs, total_size, "", nil
        }</span>

        <span class="cov8" title="1">npt, err := opts.NextPageToken(jobs[opts.PageSize])
        return jobs[:opts.PageSize], total_size, npt, err</span>
}

func (s *JobStore) buildSelectJobsQuery(selectCount bool, opts *list.Options,
        filterContext *model.FilterContext) (string, []interface{}, error) <span class="cov8" title="1">{

        var filteredSelectBuilder sq.SelectBuilder
        var err error

        refKey := filterContext.ReferenceKey
        if refKey != nil &amp;&amp; refKey.Type == model.NamespaceResourceType </span><span class="cov8" title="1">{
                filteredSelectBuilder, err = list.FilterOnNamespace("jobs", jobColumns,
                        selectCount, refKey.ID)
        }</span> else<span class="cov8" title="1"> {
                filteredSelectBuilder, err = list.FilterOnResourceReference("jobs", jobColumns,
                        model.JobResourceType, selectCount, filterContext)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", nil, util.NewInternalServerError(err, "Failed to list jobs: %v", err)
        }</span>

        <span class="cov8" title="1">sqlBuilder := opts.AddFilterToSelect(filteredSelectBuilder)

        // If we're not just counting, then also add select columns and perform a left join
        // to get resource reference information. Also add pagination.
        if !selectCount </span><span class="cov8" title="1">{
                sqlBuilder = opts.AddPaginationToSelect(sqlBuilder)
                sqlBuilder = s.addResourceReferences(sqlBuilder)
                sqlBuilder = opts.AddSortingToSelect(sqlBuilder)
        }</span>
        <span class="cov8" title="1">sql, args, err := sqlBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, util.NewInternalServerError(err, "Failed to list jobs: %v", err)
        }</span>

        <span class="cov8" title="1">return sql, args, err</span>
}

func (s *JobStore) GetJob(id string) (*model.Job, error) <span class="cov8" title="1">{
        sql, args, err := s.addResourceReferences(sq.Select(jobColumns...).From("jobs")).
                Where(sq.Eq{"uuid": id}).
                Limit(1).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to create query to get job: %v",
                        err.Error())
        }</span>
        <span class="cov8" title="1">row, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "Failed to get job: %v",
                        err.Error())
        }</span>
        <span class="cov8" title="1">defer row.Close()
        jobs, err := s.scanRows(row)
        if err != nil || len(jobs) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to get job: %v", err.Error())
        }</span>
        <span class="cov8" title="1">if len(jobs) == 0 </span><span class="cov8" title="1">{
                return nil, util.NewResourceNotFoundError("Job", fmt.Sprint(id))
        }</span>
        <span class="cov8" title="1">return jobs[0], nil</span>
}

func (s *JobStore) addResourceReferences(filteredSelectBuilder sq.SelectBuilder) sq.SelectBuilder <span class="cov8" title="1">{
        resourceRefConcatQuery := s.db.Concat([]string{`"["`, s.db.GroupConcat("r.Payload", ","), `"]"`}, "")
        return sq.
                Select("jobs.*", resourceRefConcatQuery+" AS refs").
                FromSelect(filteredSelectBuilder, "jobs").
                // Append all the resource references for the run as a json column
                LeftJoin("(select * from resource_references where ResourceType='Job') AS r ON jobs.UUID=r.ResourceUUID").
                GroupBy("jobs.UUID")
}</span>

func (s *JobStore) scanRows(r *sql.Rows) ([]*model.Job, error) <span class="cov8" title="1">{
        var jobs []*model.Job
        for r.Next() </span><span class="cov8" title="1">{
                var uuid, displayName, name, namespace, pipelineId, pipelineName, conditions, serviceAccount,
                        description, parameters, pipelineSpecManifest, workflowSpecManifest string
                var cronScheduleStartTimeInSec, cronScheduleEndTimeInSec,
                        periodicScheduleStartTimeInSec, periodicScheduleEndTimeInSec, intervalSecond sql.NullInt64
                var cron, resourceReferencesInString, runtimeParameters, pipelineRoot sql.NullString
                var enabled, noCatchup bool
                var createdAtInSec, updatedAtInSec, maxConcurrency int64
                err := r.Scan(
                        &amp;uuid, &amp;displayName, &amp;name, &amp;namespace, &amp;serviceAccount, &amp;description,
                        &amp;maxConcurrency, &amp;noCatchup, &amp;createdAtInSec, &amp;updatedAtInSec, &amp;enabled,
                        &amp;cronScheduleStartTimeInSec, &amp;cronScheduleEndTimeInSec, &amp;cron,
                        &amp;periodicScheduleStartTimeInSec, &amp;periodicScheduleEndTimeInSec, &amp;intervalSecond,
                        &amp;pipelineId, &amp;pipelineName, &amp;pipelineSpecManifest, &amp;workflowSpecManifest, &amp;parameters,
                        &amp;conditions, &amp;runtimeParameters, &amp;pipelineRoot, &amp;resourceReferencesInString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">resourceReferences, err := parseResourceReferences(resourceReferencesInString)
                runtimeConfig := parseRuntimeConfig(runtimeParameters, pipelineRoot)
                jobs = append(jobs, &amp;model.Job{
                        UUID:               uuid,
                        DisplayName:        displayName,
                        Name:               name,
                        Namespace:          namespace,
                        ServiceAccount:     serviceAccount,
                        Description:        description,
                        Enabled:            enabled,
                        Conditions:         conditions,
                        MaxConcurrency:     maxConcurrency,
                        NoCatchup:          noCatchup,
                        ResourceReferences: resourceReferences,
                        Trigger: model.Trigger{
                                CronSchedule: model.CronSchedule{
                                        CronScheduleStartTimeInSec: NullInt64ToPointer(cronScheduleStartTimeInSec),
                                        CronScheduleEndTimeInSec:   NullInt64ToPointer(cronScheduleEndTimeInSec),
                                        Cron:                       NullStringToPointer(cron),
                                },
                                PeriodicSchedule: model.PeriodicSchedule{
                                        PeriodicScheduleStartTimeInSec: NullInt64ToPointer(periodicScheduleStartTimeInSec),
                                        PeriodicScheduleEndTimeInSec:   NullInt64ToPointer(periodicScheduleEndTimeInSec),
                                        IntervalSecond:                 NullInt64ToPointer(intervalSecond),
                                },
                        },
                        PipelineSpec: model.PipelineSpec{
                                PipelineId:           pipelineId,
                                PipelineName:         pipelineName,
                                PipelineSpecManifest: pipelineSpecManifest,
                                WorkflowSpecManifest: workflowSpecManifest,
                                Parameters:           parameters,
                                RuntimeConfig:        runtimeConfig,
                        },
                        CreatedAtInSec: createdAtInSec,
                        UpdatedAtInSec: updatedAtInSec,
                })</span>
        }
        <span class="cov8" title="1">return jobs, nil</span>
}

func (s *JobStore) DeleteJob(id string) error <span class="cov8" title="1">{
        jobSql, jobArgs, err := sq.Delete("jobs").Where(sq.Eq{"UUID": id}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to delete job: %s", id)
        }</span>
        // Use a transaction to make sure both run and its resource references are stored.
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to create a new transaction to delete job.")
        }</span>
        <span class="cov8" title="1">_, err = tx.Exec(jobSql, jobArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to delete job %s from table", id)
        }</span>
        <span class="cov8" title="1">err = s.resourceReferenceStore.DeleteResourceReferences(tx, id, model.JobResourceType)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to delete resource references from table for job %v ", id)
        }</span>
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to delete job %v and its resource references from table", id)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *JobStore) CreateJob(j *model.Job) (*model.Job, error) <span class="cov8" title="1">{
        jobSql, jobArgs, err := sq.
                Insert("jobs").
                SetMap(sq.Eq{
                        "UUID":                           j.UUID,
                        "DisplayName":                    j.DisplayName,
                        "Name":                           j.Name,
                        "Namespace":                      j.Namespace,
                        "ServiceAccount":                 j.ServiceAccount,
                        "Description":                    j.Description,
                        "MaxConcurrency":                 j.MaxConcurrency,
                        "NoCatchup":                      j.NoCatchup,
                        "Enabled":                        j.Enabled,
                        "Conditions":                     j.Conditions,
                        "CronScheduleStartTimeInSec":     PointerToNullInt64(j.CronScheduleStartTimeInSec),
                        "CronScheduleEndTimeInSec":       PointerToNullInt64(j.CronScheduleEndTimeInSec),
                        "Schedule":                       PointerToNullString(j.Cron),
                        "PeriodicScheduleStartTimeInSec": PointerToNullInt64(j.PeriodicScheduleStartTimeInSec),
                        "PeriodicScheduleEndTimeInSec":   PointerToNullInt64(j.PeriodicScheduleEndTimeInSec),
                        "IntervalSecond":                 PointerToNullInt64(j.IntervalSecond),
                        "CreatedAtInSec":                 j.CreatedAtInSec,
                        "UpdatedAtInSec":                 j.UpdatedAtInSec,
                        "PipelineId":                     j.PipelineId,
                        "PipelineName":                   j.PipelineName,
                        "PipelineSpecManifest":           j.PipelineSpecManifest,
                        "WorkflowSpecManifest":           j.WorkflowSpecManifest,
                        "Parameters":                     j.Parameters,
                        "RuntimeParameters":              j.PipelineSpec.RuntimeConfig.Parameters,
                        "PipelineRoot":                   j.PipelineSpec.RuntimeConfig.PipelineRoot,
                }).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to create query to add job to job table: %v",
                        err.Error())
        }</span>

        // Use a transaction to make sure both job and its resource references are stored.
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "Failed to create a new transaction to create job.")
        }</span>
        <span class="cov8" title="1">_, err = tx.Exec(jobSql, jobArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, util.NewInternalServerError(err, "Failed to store job %v to table", j.Name)
        }</span>
        <span class="cov8" title="1">err = s.resourceReferenceStore.CreateResourceReferences(tx, j.ResourceReferences)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, util.NewInternalServerError(err, "Failed to store resource references to table for job %v ", j.Name)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, util.NewInternalServerError(err, "Failed to store job %v and its resource references to table", j.Name)
        }</span>
        <span class="cov8" title="1">return j, nil</span>
}

func (s *JobStore) EnableJob(id string, enabled bool) error <span class="cov8" title="1">{
        now := s.time.Now().Unix()
        sql, args, err := sq.
                Update("jobs").
                SetMap(sq.Eq{
                        "Enabled":        enabled,
                        "UpdatedAtInSec": now}).
                Where(sq.Eq{"UUID": string(id)}).
                Where(sq.Eq{"Enabled": !enabled}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "Error when creating query to enable job %v to %v", id, enabled)
        }</span>
        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Error when enabling job %v to %v", id, enabled)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *JobStore) UpdateJob(swf *util.ScheduledWorkflow) error <span class="cov8" title="1">{
        now := s.time.Now().Unix()
        parameters, err := swf.ParametersAsString()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sql, args, err := sq.
                Update("jobs").
                SetMap(sq.Eq{
                        "Name":                           swf.Name,
                        "Namespace":                      swf.Namespace,
                        "Enabled":                        swf.Spec.Enabled,
                        "Conditions":                     swf.ConditionSummary(),
                        "MaxConcurrency":                 swf.MaxConcurrencyOr0(),
                        "NoCatchup":                      swf.NoCatchupOrFalse(),
                        "Parameters":                     parameters,
                        "UpdatedAtInSec":                 now,
                        "CronScheduleStartTimeInSec":     PointerToNullInt64(swf.CronScheduleStartTimeInSecOrNull()),
                        "CronScheduleEndTimeInSec":       PointerToNullInt64(swf.CronScheduleEndTimeInSecOrNull()),
                        "Schedule":                       swf.CronOrEmpty(),
                        "PeriodicScheduleStartTimeInSec": PointerToNullInt64(swf.PeriodicScheduleStartTimeInSecOrNull()),
                        "PeriodicScheduleEndTimeInSec":   PointerToNullInt64(swf.PeriodicScheduleEndTimeInSecOrNull()),
                        "IntervalSecond":                 swf.IntervalSecondOr0()}).
                Where(sq.Eq{"UUID": string(swf.UID)}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Error while creating query to update job with scheduled workflow: %v: %+v",
                        err, swf.ScheduledWorkflow)
        }</span>
        <span class="cov8" title="1">r, err := s.db.Exec(sql, args...)

        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err,
                        "Error while updating job with scheduled workflow: %v: %+v",
                        err, swf.ScheduledWorkflow)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := r.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Error getting affected rows while updating job with scheduled workflow: %v: %+v",
                        err, swf.ScheduledWorkflow)
        }</span>
        <span class="cov8" title="1">if rowsAffected &lt;= 0 </span><span class="cov8" title="1">{
                return util.NewInvalidInputError(
                        "There is no job corresponding to this scheduled workflow: %v/%v/%v",
                        swf.UID, swf.Namespace, swf.Name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// factory function for job store
func NewJobStore(db *DB, time util.TimeInterface) *JobStore <span class="cov8" title="1">{
        return &amp;JobStore{
                db:                     db,
                resourceReferenceStore: NewResourceReferenceStore(db),
                time:                   time,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "io"

        minio "github.com/minio/minio-go/v6"
)

// Create interface for minio client struct, making it more unit testable.
type MinioClientInterface interface {
        PutObject(bucketName, objectName string, reader io.Reader, objectSize int64, opts minio.PutObjectOptions) (n int64, err error)
        GetObject(bucketName, objectName string, opts minio.GetObjectOptions) (io.Reader, error)
        DeleteObject(bucketName, objectName string) error
}

type MinioClient struct {
        Client *minio.Client
}

func (c *MinioClient) PutObject(bucketName, objectName string, reader io.Reader, objectSize int64, opts minio.PutObjectOptions) (n int64, err error) <span class="cov0" title="0">{
        return c.Client.PutObject(bucketName, objectName, reader, objectSize, opts)
}</span>

func (c *MinioClient) GetObject(bucketName, objectName string, opts minio.GetObjectOptions) (io.Reader, error) <span class="cov0" title="0">{
        return c.Client.GetObject(bucketName, objectName, opts)
}</span>

func (c *MinioClient) DeleteObject(bucketName, objectName string) error <span class="cov0" title="0">{
        return c.Client.RemoveObject(bucketName, objectName)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "bytes"
        "io"

        "github.com/minio/minio-go/v6"
        "github.com/pkg/errors"
)

type FakeMinioClient struct {
        minioClient map[string][]byte
}

func NewFakeMinioClient() *FakeMinioClient <span class="cov8" title="1">{
        return &amp;FakeMinioClient{
                minioClient: make(map[string][]byte),
        }
}</span>

func (c *FakeMinioClient) PutObject(bucketName, objectName string, reader io.Reader,
        objectSize int64, opts minio.PutObjectOptions) (n int64, err error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        buf.ReadFrom(reader)
        c.minioClient[objectName] = buf.Bytes()
        return 1, nil
}</span>

func (c *FakeMinioClient) GetObject(bucketName, objectName string,
        opts minio.GetObjectOptions) (io.Reader, error) <span class="cov8" title="1">{
        if _, ok := c.minioClient[objectName]; !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object not found")
        }</span>
        <span class="cov8" title="1">return bytes.NewReader(c.minioClient[objectName]), nil</span>
}

func (c *FakeMinioClient) DeleteObject(bucketName, objectName string) error <span class="cov8" title="1">{
        if _, ok := c.minioClient[objectName]; !ok </span><span class="cov0" title="0">{
                return errors.New("object not found")
        }</span>
        <span class="cov8" title="1">delete(c.minioClient, objectName)
        return nil</span>
}

func (c *FakeMinioClient) GetObjectCount() int <span class="cov8" title="1">{
        return len(c.minioClient)
}</span>

func (c *FakeMinioClient) ExistObject(objectName string) bool <span class="cov8" title="1">{
        _, ok := c.minioClient[objectName]
        return ok
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "bytes"
        "path"
        "regexp"

        "github.com/ghodss/yaml"
        "github.com/kubeflow/pipelines/backend/src/common/util"
        minio "github.com/minio/minio-go/v6"
)

const (
        multipartDefaultSize = -1
)

// Interface for object store.
type ObjectStoreInterface interface {
        AddFile(template []byte, filePath string) error
        DeleteFile(filePath string) error
        GetFile(filePath string) ([]byte, error)
        AddAsYamlFile(o interface{}, filePath string) error
        GetFromYamlFile(o interface{}, filePath string) error
        GetPipelineKey(pipelineId string) string
}

// Managing pipeline using Minio
type MinioObjectStore struct {
        minioClient      MinioClientInterface
        bucketName       string
        baseFolder       string
        disableMultipart bool
}

// GetPipelineKey adds the configured base folder to pipeline id.
func (m *MinioObjectStore) GetPipelineKey(pipelineID string) string <span class="cov8" title="1">{
        return path.Join(m.baseFolder, pipelineID)
}</span>

func (m *MinioObjectStore) AddFile(file []byte, filePath string) error <span class="cov8" title="1">{

        var parts int64

        if m.disableMultipart </span><span class="cov0" title="0">{
                parts = int64(len(file))
        }</span> else<span class="cov8" title="1"> {
                parts = multipartDefaultSize
        }</span>

        <span class="cov8" title="1">_, err := m.minioClient.PutObject(
                m.bucketName, filePath, bytes.NewReader(file),
                parts, minio.PutObjectOptions{ContentType: "application/octet-stream"})
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to store file %v", filePath)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MinioObjectStore) DeleteFile(filePath string) error <span class="cov8" title="1">{
        err := m.minioClient.DeleteObject(m.bucketName, filePath)
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to delete file %v", filePath)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MinioObjectStore) GetFile(filePath string) ([]byte, error) <span class="cov8" title="1">{
        reader, err := m.minioClient.GetObject(m.bucketName, filePath, minio.GetObjectOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "Failed to get file %v", filePath)
        }</span>

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        buf.ReadFrom(reader)

        bytes := buf.Bytes()

        // Remove single part signature if exists
        if m.disableMultipart </span><span class="cov0" title="0">{
                re := regexp.MustCompile(`\w+;chunk-signature=\w+`)
                bytes = []byte(re.ReplaceAllString(string(bytes), ""))
        }</span>

        <span class="cov8" title="1">return bytes, nil</span>
}

func (m *MinioObjectStore) AddAsYamlFile(o interface{}, filePath string) error <span class="cov8" title="1">{
        bytes, err := yaml.Marshal(o)
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "Failed to marshal file %v: %v", filePath, err.Error())
        }</span>
        <span class="cov8" title="1">err = m.AddFile(bytes, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return util.Wrap(err, "Failed to add a yaml file.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MinioObjectStore) GetFromYamlFile(o interface{}, filePath string) error <span class="cov8" title="1">{
        bytes, err := m.GetFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return util.Wrap(err, "Failed to read from a yaml file.")
        }</span>
        <span class="cov8" title="1">err = yaml.Unmarshal(bytes, o)
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to unmarshal file %v: %v", filePath, err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func buildPath(folder, file string) string <span class="cov0" title="0">{
        return folder + "/" + file
}</span>

func NewMinioObjectStore(minioClient MinioClientInterface, bucketName string, baseFolder string, disableMultipart bool) *MinioObjectStore <span class="cov0" title="0">{
        return &amp;MinioObjectStore{minioClient: minioClient, bucketName: bucketName, baseFolder: baseFolder, disableMultipart: disableMultipart}
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

// Return the object store with faked minio client.
func NewFakeObjectStore() ObjectStoreInterface <span class="cov0" title="0">{
        return NewMinioObjectStore(NewFakeMinioClient(), "", "pipelines", false)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2018-2022 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "database/sql"
        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/golang/glog"
        "github.com/kubeflow/pipelines/backend/src/apiserver/list"
        "github.com/kubeflow/pipelines/backend/src/apiserver/model"
        "github.com/kubeflow/pipelines/backend/src/common/util"
)

var (
        // TODO (gkcalat): consider removing after KFP v2 GA if users are not affected.
        // `pipelines` joined with `pipeline_versions`
        // This supports v1beta1 behavior.
        // The order of the selected columns must match the order used in scan rows.
        joinedColumns = []string{
                "pipelines.UUID",
                "pipelines.CreatedAtInSec",
                "pipelines.Name",
                "pipelines.Description",
                // "pipelines.Parameters",
                "pipelines.Status",
                "pipelines.Namespace",
                // "pipelines.DefaultVersionId",
                // "pipelines.Url",
                "pipeline_versions.UUID",
                "pipeline_versions.CreatedAtInSec",
                "pipeline_versions.Name",
                "pipeline_versions.Parameters",
                "pipeline_versions.PipelineId",
                "pipeline_versions.Status",
                "pipeline_versions.CodeSourceUrl",
                "pipeline_versions.Description",
                // "pipeline_versions.PipelineSpec",
                // "pipeline_versions.PipelineSpecURI",
        }

        // `pipelines`
        // The order of the selected columns must match the order used in scan rows.
        pipelineColumns = []string{
                "pipelines.UUID",
                "pipelines.CreatedAtInSec",
                "pipelines.Name",
                "pipelines.Description",
                // "pipelines.Parameters",
                "pipelines.Status",
                "pipelines.Namespace",
                // "pipelines.DefaultVersionId",
                // "pipelines.Url",
        }

        // `pipeline_versions`
        // The order of the selected columns must match the order used in scan rows.
        pipelineVersionColumns = []string{
                "pipeline_versions.UUID",
                "pipeline_versions.CreatedAtInSec",
                "pipeline_versions.Name",
                "pipeline_versions.Parameters",
                "pipeline_versions.PipelineId",
                "pipeline_versions.Status",
                "pipeline_versions.CodeSourceUrl",
                "pipeline_versions.Description",
                "pipeline_versions.PipelineSpec",
                "pipeline_versions.PipelineSpecURI",
        }
)

type PipelineStoreInterface interface {
        // TODO (gkcalat): As these calls use joins on two (potentially) large sets with one-many relationship,
        // let's keep them to avoid performance issues. consider removing after KFP v2 GA if users are not affected.
        //
        // `pipelines` left joined with `pipeline_versions`
        // This supports v1beta1 behavior.
        GetPipelineByNameAndNamespaceV1(name string, namespace string) (*model.Pipeline, error)
        ListPipelinesV1(filterContext *model.FilterContext, opts *list.Options) ([]*model.Pipeline, int, string, error)

        // `pipelines`
        CreatePipeline(pipeline *model.Pipeline) (*model.Pipeline, error)
        GetPipelineWithStatus(pipelineId string, status model.PipelineStatus) (*model.Pipeline, error)
        GetPipeline(pipelineId string) (*model.Pipeline, error)
        GetPipelineByNameAndNamespace(name string, namespace string) (*model.Pipeline, error)
        ListPipelines(filterContext *model.FilterContext, opts *list.Options) ([]*model.Pipeline, int, string, error)
        UpdatePipelineStatus(pipelineId string, status model.PipelineStatus) error
        DeletePipeline(pipelineId string) error
        //UpdatePipelineDefaultVersionV1(pipelineId string, defaultPipelineVersionId string) error // Used in v1beta1 only

        // `pipeline_versions`
        CreatePipelineVersion(pipelineVersion *model.PipelineVersion) (*model.PipelineVersion, error)
        GetPipelineVersionWithStatus(pipelineVersionId string, status model.PipelineVersionStatus) (*model.PipelineVersion, error)
        GetPipelineVersion(pipelineVersionId string) (*model.PipelineVersion, error)
        GetLatestPipelineVersion(pipelineId string) (*model.PipelineVersion, error)
        ListPipelineVersions(pipelineId string, opts *list.Options) ([]*model.PipelineVersion, int, string, error)
        UpdatePipelineVersionStatus(pipelineVersionId string, status model.PipelineVersionStatus) error
        DeletePipelineVersion(pipelineVersionId string) error
        //DeletePipelineVersionAndUpdateDefaultV1(pipelineVersionId string) error // Used in v1beta1 only
}

type PipelineStore struct {
        db   *DB
        time util.TimeInterface
        uuid util.UUIDGeneratorInterface
}

// Factory function for pipeline store
func NewPipelineStore(db *DB, time util.TimeInterface, uuid util.UUIDGeneratorInterface) *PipelineStore <span class="cov8" title="1">{
        return &amp;PipelineStore{db: db, time: time, uuid: uuid}
}</span>

// SetUUIDGenerator is for unit tests in other packages who need to set uuid,
// since uuid is not exported.
func (s *PipelineStore) SetUUIDGenerator(new_uuid util.UUIDGeneratorInterface) <span class="cov0" title="0">{
        s.uuid = new_uuid
}</span>

// Converts SQL response into []Pipeline (default version is set to nil).
func (s *PipelineStore) scanPipelinesRows(rows *sql.Rows) ([]*model.Pipeline, error) <span class="cov8" title="1">{
        var pipelines []*model.Pipeline
        for rows.Next() </span><span class="cov8" title="1">{
                var uuid, name, status, description, namespace sql.NullString
                // var parameters, defaultVersionId, url sql.NullString
                var createdAtInSec sql.NullInt64
                if err := rows.Scan(
                        &amp;uuid,
                        &amp;createdAtInSec,
                        &amp;name,
                        &amp;description,
                        // &amp;parameters,
                        &amp;status,
                        &amp;namespace,
                        // &amp;defaultVersionId,
                        // &amp;url,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if uuid.Valid </span><span class="cov8" title="1">{
                        pipelines = append(
                                pipelines,
                                &amp;model.Pipeline{
                                        UUID:           uuid.String,
                                        CreatedAtInSec: createdAtInSec.Int64,
                                        Name:           name.String,
                                        Description:    description.String,
                                        Status:         model.PipelineStatus(status.String),
                                        Namespace:      namespace.String,
                                },
                        )
                }</span>
        }
        <span class="cov8" title="1">return pipelines, nil</span>
}

// Converts SQL response into []PipelineVersion.
func (s *PipelineStore) scanPipelineVersionsRows(rows *sql.Rows) ([]*model.PipelineVersion, error) <span class="cov8" title="1">{
        var pipelineVersions []*model.PipelineVersion
        for rows.Next() </span><span class="cov8" title="1">{
                var uuid, name, parameters, pipelineId, codeSourceUrl, status, description, pipelineSpec, pipelineSpecURI sql.NullString
                var createdAtInSec sql.NullInt64
                if err := rows.Scan(
                        &amp;uuid,
                        &amp;createdAtInSec,
                        &amp;name,
                        &amp;parameters,
                        &amp;pipelineId,
                        &amp;status,
                        &amp;codeSourceUrl,
                        &amp;description,
                        &amp;pipelineSpec,
                        &amp;pipelineSpecURI,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if uuid.Valid </span><span class="cov8" title="1">{
                        pipelineVersions = append(
                                pipelineVersions,
                                &amp;model.PipelineVersion{
                                        UUID:            uuid.String,
                                        CreatedAtInSec:  createdAtInSec.Int64,
                                        Name:            name.String,
                                        Parameters:      parameters.String,
                                        PipelineId:      pipelineId.String,
                                        CodeSourceUrl:   codeSourceUrl.String,
                                        Status:          model.PipelineVersionStatus(status.String),
                                        Description:     description.String,
                                        PipelineSpec:    pipelineSpec.String,
                                        PipelineSpecURI: pipelineSpecURI.String,
                                },
                        )
                }</span>
        }
        <span class="cov8" title="1">return pipelineVersions, nil</span>
}

// TODO (gkcalat): consider removing after KFP v2 GA if users are not affected.
// Parses SQL results of joining `pipelines` and `pipeline_versions` tables into []Pipelines.
// This supports v1beta1 behavior.
func (s *PipelineStore) scanJoinedRows(rows *sql.Rows) ([]*model.Pipeline, error) <span class="cov8" title="1">{
        var pipelines []*model.Pipeline
        for rows.Next() </span><span class="cov8" title="1">{
                var uuid, name, description string
                var namespace sql.NullString
                var createdAtInSec int64
                var status model.PipelineStatus
                var versionUUID, versionName, versionParameters, versionPipelineId, versionCodeSourceUrl, versionStatus, versionDescription sql.NullString
                var versionCreatedAtInSec sql.NullInt64
                if err := rows.Scan(
                        &amp;uuid,
                        &amp;createdAtInSec,
                        &amp;name,
                        &amp;description,
                        // &amp;parameters,
                        &amp;status,
                        &amp;namespace,
                        // &amp;defaultVersionId,
                        &amp;versionUUID,
                        &amp;versionCreatedAtInSec,
                        &amp;versionName,
                        &amp;versionParameters,
                        &amp;versionPipelineId,
                        &amp;versionStatus,
                        &amp;versionCodeSourceUrl,
                        &amp;versionDescription); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // if defaultVersionId.Valid {
                //         pipelines = append(
                //                 pipelines,
                //                 &amp;model.Pipeline{
                //                         UUID:           uuid,
                //                         CreatedAtInSec: createdAtInSec,
                //                         Name:           name,
                //                         Description:    description,
                //                         Status:         status,
                //                         Namespace:      namespace.String,
                //                 },
                //         )
                // } else {
                <span class="cov8" title="1">pipelines = append(
                        pipelines,
                        &amp;model.Pipeline{
                                UUID:           uuid,
                                CreatedAtInSec: createdAtInSec,
                                Name:           name,
                                Description:    description,
                                Status:         status,
                                Namespace:      namespace.String,
                        },
                )</span>
                // }
        }
        <span class="cov8" title="1">return pipelines, nil</span>
}

// Inserts a record into `pipelines` table.
// Call CreatePipelineVersion to create a record in`pipeline_versions`.
func (s *PipelineStore) CreatePipeline(p *model.Pipeline) (*model.Pipeline, error) <span class="cov8" title="1">{
        newPipeline := *p

        // Set pipeline creation time
        newPipeline.CreatedAtInSec = s.time.Now().Unix()

        // Set pipeline id
        id, err := s.uuid.NewRandom()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to create a pipeline UUID.")
        }</span>
        <span class="cov8" title="1">newPipeline.UUID = id.String()

        // Create a query for the KFP DB
        sql, args, err := sq.
                Insert("pipelines").
                SetMap(
                        sq.Eq{
                                "UUID":           newPipeline.UUID,
                                "CreatedAtInSec": newPipeline.CreatedAtInSec,
                                "Name":           newPipeline.Name,
                                "Description":    newPipeline.Description,
                                "Status":         string(newPipeline.Status),
                                "Namespace":      newPipeline.Namespace,
                        },
                ).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to create query to insert pipeline to pipeline table: %v",
                        err.Error())
        }</span>

        // Insert into pipelines table
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err,
                        `PipelineStore: Failed to start a transaction to create a new pipeline: %v`,
                        err.Error())
        }</span>
        <span class="cov8" title="1">_, err = tx.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                if s.db.IsDuplicateError(err) </span><span class="cov8" title="1">{
                        tx.Rollback()
                        return nil, util.NewAlreadyExistError(
                                "PipelineStore: Failed to create a new pipeline. The name %v already exist. Please specify a new name.", p.Name)
                }</span>
                <span class="cov0" title="0">tx.Rollback()
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to add pipeline to pipeline table: %v",
                        err.Error())</span>
        }
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, util.NewInternalServerError(err,
                        `PipelineStore: Failed to commit pipeline creation in a SQL
                        transaction: %v`, err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;newPipeline, nil</span>
}

// Creates a PipelineVersion
func (s *PipelineStore) CreatePipelineVersion(pv *model.PipelineVersion) (*model.PipelineVersion, error) <span class="cov8" title="1">{
        newPipelineVersion := *pv

        // Set pipeline version id
        id, err := s.uuid.NewRandom()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to generate a pipeline version UUID.")
        }</span>
        <span class="cov8" title="1">newPipelineVersion.UUID = id.String()

        // Set creation time
        newPipelineVersion.CreatedAtInSec = s.time.Now().Unix()

        // Prepare a query for inserting new version
        versionSql, versionArgs, versionErr := sq.
                Insert("pipeline_versions").
                SetMap(
                        sq.Eq{
                                "UUID":            newPipelineVersion.UUID,
                                "CreatedAtInSec":  newPipelineVersion.CreatedAtInSec,
                                "Name":            newPipelineVersion.Name,
                                "Parameters":      newPipelineVersion.Parameters,
                                "PipelineId":      newPipelineVersion.PipelineId,
                                "Status":          string(newPipelineVersion.Status),
                                "CodeSourceUrl":   newPipelineVersion.CodeSourceUrl,
                                "Description":     newPipelineVersion.Description,
                                "PipelineSpec":    newPipelineVersion.PipelineSpec,
                                "PipelineSpecURI": newPipelineVersion.PipelineSpecURI,
                        },
                ).
                ToSql()
        if versionErr != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(
                        versionErr,
                        "PipelineStore: Failed to create query to insert a pipeline version: %v",
                        versionErr.Error())
        }</span>

        // Insert a new pipeline version.
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(
                        err,
                        "PipelineStore: Failed to insert a new pipeline version: %v",
                        err.Error())
        }</span>
        <span class="cov8" title="1">_, err = tx.Exec(versionSql, versionArgs...)
        if err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                if s.db.IsDuplicateError(err) </span><span class="cov8" title="1">{
                        return nil, util.NewAlreadyExistError(
                                "PipelineStore: Failed to create a new pipeline version. The name %v already exist. Please specify a new name: %v", pv.Name, err.Error())
                }</span>
                <span class="cov0" title="0">return nil, util.NewInternalServerError(err, "PipelineStore: Failed to add a pipeline version: %v",
                        err.Error())</span>
        }
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to create a new pipeline version: %v",
                        err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;newPipelineVersion, nil</span>
}

// Returns a pipeline wit status = PipelineReady
func (s *PipelineStore) GetPipeline(id string) (*model.Pipeline, error) <span class="cov8" title="1">{
        return s.GetPipelineWithStatus(id, model.PipelineReady)
}</span>

// Returns a pipeline with a specified status.
// Changes behavior compare to v1beta1: does not join with a default pipeline version.
func (s *PipelineStore) GetPipelineWithStatus(id string, status model.PipelineStatus) (*model.Pipeline, error) <span class="cov8" title="1">{
        // Prepare the query
        sql, args, err := sq.
                Select(pipelineColumns...).
                From("pipelines").
                Where(sq.And{sq.Eq{"pipelines.UUID": id}, sq.Eq{"pipelines.Status": status}}).
                Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to create query to get a pipeline: %v", err.Error())
        }</span>

        // Execute the query
        <span class="cov8" title="1">r, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to get a pipeline: %v", err.Error())
        }</span>
        <span class="cov8" title="1">defer r.Close()

        // Parse results
        pipelines, err := s.scanPipelinesRows(r)
        if err != nil || len(pipelines) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to parse results of getting a pipeline: %v", err.Error())
        }</span>
        <span class="cov8" title="1">if len(pipelines) == 0 </span><span class="cov8" title="1">{
                return nil, util.NewResourceNotFoundError("Pipeline", fmt.Sprint(id))
        }</span>
        <span class="cov8" title="1">return pipelines[0], nil</span>
}

// Returns a pipeline version with status PipelineVersionReady.
func (s *PipelineStore) GetPipelineVersion(versionId string) (*model.PipelineVersion, error) <span class="cov8" title="1">{
        return s.GetPipelineVersionWithStatus(versionId, model.PipelineVersionReady)
}</span>

// Returns the latest pipeline version with status PipelineVersionReady for a given pipeline id.
func (s *PipelineStore) GetLatestPipelineVersion(pipelineId string) (*model.PipelineVersion, error) <span class="cov8" title="1">{
        // Prepare a SQL query
        sql, args, err := sq.
                Select(pipelineVersionColumns...).
                From("pipeline_versions").
                Where(sq.And{sq.Eq{"pipeline_versions.PipelineId": pipelineId}, sq.Eq{"pipeline_versions.Status": model.PipelineVersionReady}}).
                OrderBy("pipeline_versions.CreatedAtInSec DESC").
                Limit(1).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to create query to fetch the latest pipeline version: %v", err.Error())
        }</span>

        // Execute the query
        <span class="cov8" title="1">r, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed fetching the latest pipeline version: %v", err.Error())
        }</span>
        <span class="cov8" title="1">defer r.Close()

        // Parse results
        versions, err := s.scanPipelineVersionsRows(r)
        if err != nil || len(versions) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to parse the latest pipeline version from SQL response: %v", err.Error())
        }</span>
        <span class="cov8" title="1">if len(versions) == 0 </span><span class="cov0" title="0">{
                return nil, util.NewResourceNotFoundError("PipelineVersion", fmt.Sprint(pipelineId))
        }</span>
        <span class="cov8" title="1">return versions[0], nil</span>
}

// Returns a pipeline version with specified status.
func (s *PipelineStore) GetPipelineVersionWithStatus(versionId string, status model.PipelineVersionStatus) (*model.PipelineVersion, error) <span class="cov8" title="1">{
        // Prepare a SQL query
        sql, args, err := sq.
                Select(pipelineVersionColumns...).
                From("pipeline_versions").
                Where(sq.And{sq.Eq{"pipeline_versions.UUID": versionId}, sq.Eq{"pipeline_versions.Status": status}}).
                Limit(1).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to create query to fetch a pipeline version: %v", err.Error())
        }</span>

        // Execute the query
        <span class="cov8" title="1">r, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed fetching pipeline version: %v", err.Error())
        }</span>
        <span class="cov8" title="1">defer r.Close()

        // Parse results
        versions, err := s.scanPipelineVersionsRows(r)
        if err != nil || len(versions) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to parse a pipeline version from SQL response: %v", err.Error())
        }</span>
        <span class="cov8" title="1">if len(versions) == 0 </span><span class="cov8" title="1">{
                return nil, util.NewResourceNotFoundError("PipelineVersion", fmt.Sprint(versionId))
        }</span>
        <span class="cov8" title="1">return versions[0], nil</span>
}

// Returns the latest pipeline specified by name and namespace.
// Performance depends on the index (name, namespace) in `pipelines` table.
func (s *PipelineStore) GetPipelineByNameAndNamespace(name string, namespace string) (*model.Pipeline, error) <span class="cov8" title="1">{
        sql, args, err := sq.
                Select(pipelineColumns...).
                From("pipelines").
                Where(sq.And{
                        sq.Eq{"pipelines.Name": name},
                        sq.Eq{"pipelines.Namespace": namespace},
                        sq.Eq{"pipelines.Status": model.PipelineReady},
                }).
                OrderBy("pipelines.CreatedAtInSec DESC").
                Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to create query to get a pipeline by name and namespace: %v", err.Error())
        }</span>
        <span class="cov8" title="1">r, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to get a pipeline by name and namespace: %v", err.Error())
        }</span>
        <span class="cov8" title="1">defer r.Close()
        pipelines, err := s.scanPipelinesRows(r)
        if err != nil || len(pipelines) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore: Failed to parse results of GetPipelineByNameAndNamespace: %v", err.Error())
        }</span>
        <span class="cov8" title="1">if len(pipelines) == 0 </span><span class="cov8" title="1">{
                return nil, util.NewResourceNotFoundError("Pipeline", fmt.Sprint(name))
        }</span>
        <span class="cov8" title="1">return pipelines[0], nil</span>
}

// Runs two SQL queries in a transaction to return a list of matching pipelines, as well as their
// total_size. The total_size does not reflect the page size.
// This will not join with `pipeline_versions` table, hence, total_size is the size of pipelines, not pipeline_versions.
func (s *PipelineStore) ListPipelines(filterContext *model.FilterContext, opts *list.Options) ([]*model.Pipeline, int, string, error) <span class="cov8" title="1">{
        buildQuery := func(sqlBuilder sq.SelectBuilder) sq.SelectBuilder </span><span class="cov8" title="1">{
                query := opts.AddFilterToSelect(sqlBuilder).From("pipelines")
                if filterContext.ReferenceKey != nil &amp;&amp; filterContext.ReferenceKey.Type == model.NamespaceResourceType </span><span class="cov0" title="0">{
                        query = query.Where(
                                sq.Eq{"pipelines.Status": model.PipelineReady,
                                        "pipelines.Namespace": filterContext.ReferenceKey.ID},
                        )
                }</span> else<span class="cov8" title="1"> {
                        query = query.Where(
                                sq.Eq{"pipelines.Status": model.PipelineReady},
                        )
                }</span>
                <span class="cov8" title="1">return query</span>
        }

        // SQL for row list
        <span class="cov8" title="1">sqlSelect := buildQuery(sq.Select(pipelineColumns...))
        rowsSql, rowsArgs, err := opts.AddPaginationToSelect(sqlSelect).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to prepare a query to list pipelines: %v", err.Error())
        }</span>

        // SQL for getting total size. This matches the query to get all the rows above, in order
        // to do the same filter, but counts instead of scanning the rows.
        <span class="cov8" title="1">sizeSql, sizeArgs, err := buildQuery(sq.Select("count(*)")).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to prepare a query to count pipelines: %v", err.Error())
        }</span>

        // Use a transaction to make sure we're returning the total_size of the same rows queried
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("PipelineStore: Failed to start transaction to list pipelines")
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to start transaction to list pipelines: %v", err.Error())
        }</span>

        // Get pipelines
        <span class="cov8" title="1">rows, err := tx.Query(rowsSql, rowsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to execute SQL for listing pipelines: %v", err.Error())
        }</span>
        <span class="cov8" title="1">pipelines, err := s.scanPipelinesRows(rows)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to parse results of listing pipelines: %v", err.Error())
        }</span>
        <span class="cov8" title="1">rows.Close()

        // Count pipelines
        sizeRow, err := tx.Query(sizeSql, sizeArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to count pipelines: %v", err.Error())
        }</span>
        <span class="cov8" title="1">total_size, err := list.ScanRowToTotalSize(sizeRow)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to parse results of counting pipelines: %v", err.Error())
        }</span>
        <span class="cov8" title="1">sizeRow.Close()

        // Commit transaction
        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("PipelineStore: Failed to commit transaction to list pipelines")
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to commit listing pipelines: %v", err.Error())
        }</span>

        // Split results on multiple pages if needed
        <span class="cov8" title="1">if len(pipelines) &lt;= opts.PageSize </span><span class="cov8" title="1">{
                return pipelines, total_size, "", nil
        }</span>
        <span class="cov0" title="0">npt, err := opts.NextPageToken(pipelines[opts.PageSize])
        return pipelines[:opts.PageSize], total_size, npt, err</span>
}

// Fetches pipeline versions for a specified pipeline id
func (s *PipelineStore) ListPipelineVersions(pipelineId string, opts *list.Options) (versions []*model.PipelineVersion, totalSize int, nextPageToken string, err error) <span class="cov8" title="1">{
        buildQuery := func(sqlBuilder sq.SelectBuilder) sq.SelectBuilder </span><span class="cov8" title="1">{
                return opts.AddFilterToSelect(sqlBuilder).
                        From("pipeline_versions").
                        Where(
                                sq.And{
                                        sq.Eq{"pipeline_versions.PipelineId": pipelineId},
                                        sq.Eq{"pipeline_versions.Status": model.PipelineVersionReady},
                                },
                        )
        }</span>

        // Prepare a SQL query
        <span class="cov8" title="1">sqlSelect := buildQuery(sq.Select(pipelineVersionColumns...))
        rowsSql, rowsArgs, err := opts.AddPaginationToSelect(sqlSelect).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to prepare a query for listing pipeline versions: %v.", err.Error())
        }</span>

        // Query for getting total size. This matches the query to get all the rows above, in order
        // to do the same filter, but counts instead of scanning the rows.
        <span class="cov8" title="1">sizeSql, sizeArgs, err := buildQuery(sq.Select("count(*)")).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to prepare a query to count pipeline versions: %v", err.Error())
        }</span>

        // Use a transaction to make sure we're returning the total_size of the same rows queried
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                glog.Errorf("PipelineStore: Failed to begin SQL query listing pipeline versions.")
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to begin SQL query listing pipeline versions: %v.", err.Error())
        }</span>

        // Fetch the rows
        <span class="cov8" title="1">rows, err := tx.Query(rowsSql, rowsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to list pipeline versions: %v.", err.Error())
        }</span>
        <span class="cov8" title="1">pipelineVersions, err := s.scanPipelineVersionsRows(rows)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to parse results of listing pipeline versions: %v.", err.Error())
        }</span>
        <span class="cov8" title="1">rows.Close()

        // Count pipelines
        sizeRow, err := tx.Query(sizeSql, sizeArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to count pipeline versions: %v", err.Error())
        }</span>
        <span class="cov8" title="1">total_size, err := list.ScanRowToTotalSize(sizeRow)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to parse results of counting pipeline versions: %v", err.Error())
        }</span>
        <span class="cov8" title="1">sizeRow.Close()

        // Commit the transaction
        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("PipelineStore: Failed to commit transaction to list pipeline versions")
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore: Failed to commit transaction to list pipeline versions: %v.", err.Error())
        }</span>

        // Split results on multiple pages if needed
        <span class="cov8" title="1">if len(pipelineVersions) &lt;= opts.PageSize </span><span class="cov8" title="1">{
                return pipelineVersions, total_size, "", nil
        }</span>
        <span class="cov8" title="1">npt, err := opts.NextPageToken(pipelineVersions[opts.PageSize])
        return pipelineVersions[:opts.PageSize], total_size, npt, err</span>
}

// Executes a SQL query with arguments and throws standardized error messages
func (s *PipelineStore) ExecuteSQL(sql string, args []interface{}, op string, obj string) error <span class="cov8" title="1">{
        // Execute the query
        _, err := s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                // tx.Rollback()
                return util.NewInternalServerError(
                        err,
                        "PipelineStore: Failed to execute a query to %v a (an) %v: %v",
                        op,
                        obj,
                        err.Error(),
                )
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Updates status of a pipeline
func (s *PipelineStore) UpdatePipelineStatus(id string, status model.PipelineStatus) error <span class="cov8" title="1">{
        // Prepare the query
        sql, args, err := sq.
                Update("pipelines").
                SetMap(sq.Eq{"Status": status}).
                Where(sq.Eq{"UUID": id}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "PipelineStore: Failed to create query to update the pipeline status: %s", err.Error())
        }</span>
        <span class="cov8" title="1">return s.ExecuteSQL(sql, args, "update", "pipeline status")</span>
}

// Updates status of a pipeline version
func (s *PipelineStore) UpdatePipelineVersionStatus(id string, status model.PipelineVersionStatus) error <span class="cov8" title="1">{
        sql, args, err := sq.
                Update("pipeline_versions").
                SetMap(sq.Eq{"Status": status}).
                Where(sq.Eq{"UUID": id}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "PipelineStore: Failed to create query to update the status of a pipeline version: %s", err.Error())
        }</span>
        <span class="cov8" title="1">return s.ExecuteSQL(sql, args, "update", "status of a pipeline version")</span>
}

// Removes a pipeline from the DB.
// DB should take care of the corresponding records in pipeline_versions.
func (s *PipelineStore) DeletePipeline(id string) error <span class="cov8" title="1">{
        // Prepare the query
        sql, args, err := sq.Delete("pipelines").Where(sq.Eq{"UUID": id}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "PipelineStore: Failed to create query to delete a pipeline: %v", err.Error())
        }</span>
        <span class="cov8" title="1">return s.ExecuteSQL(sql, args, "delete", "pipeline")</span>
}

// Deletes a pipeline version.
// This does not update the default version update.
func (s *PipelineStore) DeletePipelineVersion(versionId string) error <span class="cov8" title="1">{
        // Prepare the query
        sql, args, err := sq.
                Delete("pipeline_versions").
                Where(sq.Eq{"UUID": versionId}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "PipelineStore: Failed to create query to delete a pipeline version: %v", err.Error())
        }</span>
        <span class="cov8" title="1">return s.ExecuteSQL(sql, args, "delete", "pipeline version")</span>
}

// TODO (gkcalat): consider removing after KFP v2 GA if users are not affected.
// Returns the latest pipeline and the latest pipeline version specified by name and namespace.
// Performance depends on the index (name, namespace) in `pipelines` table.
// This supports v1beta1 behavior.
func (s *PipelineStore) GetPipelineByNameAndNamespaceV1(name string, namespace string) (*model.Pipeline, error) <span class="cov0" title="0">{
        sql, args, err := sq.
                Select(joinedColumns...).
                From("pipelines").
                LeftJoin("pipeline_versions on pipelines.UUID = pipeline_versions.PipelineId").
                Where(sq.And{
                        sq.Eq{"pipelines.Name": name},
                        sq.Eq{"pipelines.Namespace": namespace},
                        sq.Eq{"pipelines.Status": model.PipelineReady},
                }).
                OrderBy("pipeline_versions.CreatedAtInSec DESC", "pipelines.CreatedAtInSec DESC"). // In case of duplicate (name, namespace combination), this will return the latest PipelineVersion
                Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to create query to get pipeline and pipeline version by name and namespace: %v", err.Error())
        }</span>
        <span class="cov0" title="0">r, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to get pipeline and pipeline version by name and namespace: %v", err.Error())
        }</span>
        <span class="cov0" title="0">defer r.Close()
        pipelines, err := s.scanJoinedRows(r)
        if err != nil || len(pipelines) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to parse results of GetPipelineByNameAndNamespaceV1: %v", err.Error())
        }</span>
        <span class="cov0" title="0">if len(pipelines) == 0 </span><span class="cov0" title="0">{
                return nil, util.NewResourceNotFoundError("Pipeline and PipelineVersion", fmt.Sprint(name))
        }</span>
        <span class="cov0" title="0">return pipelines[0], nil</span>
}

// TODO (gkcalat): consider removing after KFP v2 GA if users are not affected.
// Runs two SQL queries in a transaction to return a list of matching pipelines, as well as their
// total_size. The total_size does not reflect the page size. Total_size reflects the number of pipeline_versions (not pipelines).
// This supports v1beta1 behavior.
func (s *PipelineStore) ListPipelinesV1(filterContext *model.FilterContext, opts *list.Options) ([]*model.Pipeline, int, string, error) <span class="cov8" title="1">{
        buildQuery := func(sqlBuilder sq.SelectBuilder) sq.SelectBuilder </span><span class="cov8" title="1">{
                query := opts.AddFilterToSelect(sqlBuilder).From("pipelines").
                        LeftJoin("pipeline_versions ON pipelines.UUID = pipeline_versions.PipelineId") // this results in total_size reflecting the number of pipeline_versions
                if filterContext.ReferenceKey != nil &amp;&amp; filterContext.ReferenceKey.Type == model.NamespaceResourceType </span><span class="cov0" title="0">{
                        query = query.Where(
                                sq.Eq{"pipelines.Status": model.PipelineReady,
                                        "pipelines.Namespace": filterContext.ReferenceKey.ID},
                        )
                }</span> else<span class="cov8" title="1"> {
                        query = query.Where(
                                sq.Eq{"pipelines.Status": model.PipelineReady},
                        )
                }</span>
                <span class="cov8" title="1">return query</span>
        }
        <span class="cov8" title="1">sqlBuilder := buildQuery(sq.Select(joinedColumns...))

        // SQL for row list
        rowsSql, rowsArgs, err := opts.AddPaginationToSelect(sqlBuilder).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to prepare a query to list pipelines: %v", err.Error())
        }</span>

        // SQL for getting total size. This matches the query to get all the rows above, in order
        // to do the same filter, but counts instead of scanning the rows.
        <span class="cov8" title="1">sizeSql, sizeArgs, err := buildQuery(sq.Select("count(*)")).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to prepare a query to count pipelines: %v", err.Error())
        }</span>

        // Use a transaction to make sure we're returning the total_size of the same rows queried
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                glog.Errorf("PipelineStore (v1beta1): Failed to start transaction to list pipelines")
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to start transaction to list pipelines: %v", err.Error())
        }</span>

        // Get pipelines
        <span class="cov8" title="1">rows, err := tx.Query(rowsSql, rowsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to execute SQL for listing pipelines: %v", err.Error())
        }</span>
        <span class="cov8" title="1">pipelines, err := s.scanJoinedRows(rows)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to parse results of listing pipelines: %v", err.Error())
        }</span>
        <span class="cov8" title="1">rows.Close()

        // Count pipelines
        sizeRow, err := tx.Query(sizeSql, sizeArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to count pipelines: %v", err.Error())
        }</span>
        <span class="cov8" title="1">total_size, err := list.ScanRowToTotalSize(sizeRow)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to parse results of counting pipelines: %v", err.Error())
        }</span>
        <span class="cov8" title="1">sizeRow.Close()

        // Commit transaction
        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("PipelineStore (v1beta1): Failed to commit transaction to list pipelines")
                return nil, 0, "", util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to commit listing pipelines: %v", err.Error())
        }</span>

        // Split results on multiple pages, if needed
        <span class="cov8" title="1">if len(pipelines) &lt;= opts.PageSize </span><span class="cov8" title="1">{
                return pipelines, total_size, "", nil
        }</span>
        <span class="cov8" title="1">npt, err := opts.NextPageToken(pipelines[opts.PageSize])
        return pipelines[:opts.PageSize], total_size, npt, err</span>
}

// // Deprecated in v2beta1
// // TODO (gkcalat): consider removing after KFP v2 GA if users are not affected
// // Updates the default pipeline version.
// // This is used in the v1beta1 flow of deleting a pipeline version and updating the default version to the latest one.
// func (s *PipelineStore) UpdatePipelineDefaultVersionV1(pipelineId string, versionId string) error {
//         sql, args, err := sq.
//                 Update("pipelines").
//                 SetMap(sq.Eq{"DefaultVersionId": versionId}).
//                 Where(sq.Eq{"UUID": pipelineId}).
//                 ToSql()
//         if err != nil {
//                 return util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to create query to update the pipeline default version: %s", err.Error())
//         }
//         return s.ExecuteSQL(sql, args, "update", "default pipeline version (v1beta1)")
// }

// // Deprecated in v2beta1
// // TODO (gkcalat): consider removing after KFP v2 GA if users are not affected.
// // Deletes a pipeline version and updates the corresponding default pipeline version.
// func (s *PipelineStore) DeletePipelineVersionAndUpdateDefaultV1(versionId string) error {
//         // If this version is used as default version for a pipeline, we have to
//         // find a new default version for that pipeline, which is usually the latest
//         // version of that pipeline. Then we'll have 3 operations in a single
//         // transactions: (1) delete version (2) get new default version id (3) use
//         // new default version id to update pipeline.
//         tx, err := s.db.Begin()
//         if err != nil {
//                 return util.NewInternalServerError(
//                         err,
//                         "Failed to start an transaction while trying to delete pipeline version: %v",
//                         err.Error())
//         }
//         // (1) delete version.
//         _, err = tx.Exec(
//                 "delete from pipeline_versions where UUID = ?",
//                 versionId)
//         if err != nil {
//                 tx.Rollback()
//                 return util.NewInternalServerError(
//                         err,
//                         "Failed to delete pipeline version: %v",
//                         err.Error())
//         }
//         // (2) check whether this version is used as default version.
//         r, err := tx.Query(
//                 "select UUID from pipelines where DefaultVersionId = ?",
//                 versionId)
//         if err != nil {
//                 tx.Rollback()
//                 return util.NewInternalServerError(
//                         err,
//                         `Failed to query pipelines table while deleting pipeline version:
//                         %v`,
//                         err.Error())
//         }
//         var pipelineId = ""
//         if r.Next() {
//                 if err := r.Scan(&amp;pipelineId); err != nil {
//                         tx.Rollback()
//                         return util.NewInternalServerError(
//                                 err,
//                                 "Failed to get pipeline id for version id: %v",
//                                 err.Error())
//                 }
//         }
//         r.Close()
//         if len(pipelineId) == 0 {
//                 // The deleted version is not used as a default version. So no extra
//                 // work is needed. We commit the deletion now.
//                 if err := tx.Commit(); err != nil {
//                         return util.NewInternalServerError(
//                                 err,
//                                 "Failed to delete pipeline version: %v",
//                                 err.Error())
//                 }
//                 return nil
//         }
//         // (3) find a new default version.
//         r, err = tx.Query(
//                 `select UUID from pipeline_versions
//                 where PipelineId = ? and Status = ?
//                 order by CreatedAtInSec DESC
//                 limit 1`,
//                 pipelineId,
//                 model.PipelineVersionReady)
//         if err != nil {
//                 tx.Rollback()
//                 return util.NewInternalServerError(
//                         err,
//                         "Failed to get a new default version id: %v",
//                         err.Error())
//         }
//         var newDefaultVersionId = ""
//         if r.Next() {
//                 if err := r.Scan(&amp;newDefaultVersionId); err != nil {
//                         tx.Rollback()
//                         return util.NewInternalServerError(
//                                 err,
//                                 "Failed to get a new default version id: %v",
//                                 err.Error())
//                 }
//         }
//         r.Close()
//         if len(newDefaultVersionId) == 0 {
//                 // No new default version. The pipeline's default version id will be
//                 // null.
//                 _, err = tx.Exec(
//                         "update pipelines set DefaultVersionId = null where UUID = ?",
//                         pipelineId)
//                 if err != nil {
//                         tx.Rollback()
//                         return util.NewInternalServerError(
//                                 err,
//                                 "Failed to update pipeline's default version id: %v",
//                                 err.Error())
//                 }
//         } else {
//                 _, err = tx.Exec(
//                         "update pipelines set DefaultVersionId = ? where UUID = ?",
//                         newDefaultVersionId, pipelineId)
//                 if err != nil {
//                         tx.Rollback()
//                         return util.NewInternalServerError(
//                                 err,
//                                 "Failed to update pipeline's default version id: %v",
//                                 err.Error())
//                 }
//         }
//         if err := tx.Commit(); err != nil {
//                 return util.NewInternalServerError(
//                         err,
//                         "Failed to delete pipeline version: %v",
//                         err.Error())
//         }
//         return nil
// }

// // Deprecated in v2beta1
// // Updates status for a Pipeline and a PipelineVersion in as single transaction.
// // This supports v1beta1 behavior.
// func (s *PipelineStore) UpdatePipelineAndVersionsStatus(id string, status model.PipelineStatus, pipelineVersionId string, pipelineVersionStatus model.PipelineVersionStatus) error {
//         tx, err := s.db.Begin()
//         if err != nil {
//                 return util.NewInternalServerError(
//                         err,
//                         "PipelineStore (v1beta1): Failed to Pipeline and PipelineVersion status: %s",
//                         err.Error())
//         }
//         sql, args, err := sq.
//                 Update("pipelines").
//                 SetMap(sq.Eq{"Status": status}).
//                 Where(sq.Eq{"UUID": id}).
//                 ToSql()
//         if err != nil {
//                 tx.Rollback()
//                 return util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to create query to update the pipeline status: %s", err.Error())
//         }
//         _, err = tx.Exec(sql, args...)
//         if err != nil {
//                 tx.Rollback()
//                 return util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to update the pipeline status: %s", err.Error())
//         }
//         sql, args, err = sq.
//                 Update("pipeline_versions").
//                 SetMap(sq.Eq{"Status": pipelineVersionStatus}).
//                 Where(sq.Eq{"UUID": pipelineVersionId}).
//                 ToSql()
//         if err != nil {
//                 tx.Rollback()
//                 return util.NewInternalServerError(err,
//                         `PipelineStore (v1beta1): Failed to create query to update the pipeline version
//                         status: %s`, err.Error())
//         }
//         _, err = tx.Exec(sql, args...)
//         if err != nil {
//                 tx.Rollback()
//                 return util.NewInternalServerError(err,
//                         "PipelineStore (v1beta1): Failed to update the pipeline version status: %s", err.Error())
//         }
//         if err := tx.Commit(); err != nil {
//                 return util.NewInternalServerError(err,
//                         "PipelineStore (v1beta1): Failed to update pipeline status and its version status: %v", err)
//         }
//         return nil
// }

// // Deprecated in v2beta1
// // Inserts records into both `pipelines` and `pipeline_versions` tables.
// // This supports v1beta1 behavior where pipelines and pipeline_versions tables get updated in a single transaction.
// func (s *PipelineStore) CreatePipelineV1(p *model.Pipeline) (*model.Pipeline, error) {
//         // Set up creation time, UUID and sql query for pipeline.
//         newPipeline := *p
//         now := s.time.Now().Unix()
//         newPipeline.CreatedAtInSec = now
//         id, err := s.uuid.NewRandom()
//         if err != nil {
//                 return nil, util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to create a pipeline id.")
//         }
//         newPipeline.UUID = id.String()
//         // TODO(jingzhang36): remove default version id assignment after version API
//         // is ready.
//         newPipeline.DefaultVersionId = id.String()
//         sql, args, err := sq.
//                 Insert("pipelines").
//                 SetMap(
//                         sq.Eq{
//                                 "UUID":             newPipeline.UUID,
//                                 "CreatedAtInSec":   newPipeline.CreatedAtInSec,
//                                 "Name":             newPipeline.Name,
//                                 "Description":      newPipeline.Description,
//                                 "Parameters":       newPipeline.Parameters,
//                                 "Status":           string(newPipeline.Status),
//                                 "Namespace":        newPipeline.Namespace,
//                                 "DefaultVersionId": newPipeline.DefaultVersionId}).
//                 ToSql()
//         if err != nil {
//                 return nil, util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to create query to insert pipeline to pipeline table: %v",
//                         err.Error())
//         }
//         // Set up creation time, UUID and sql query for pipeline.
//         // TODO(jingzhang36): remove version related operations from CreatePipeline
//         // when version API is ready. Before that we create an implicit version
//         // inside CreatePipeline method. And this implicit version has the same UUID
//         // as pipeline; and thus FE can use either pipeline UUID or version UUID to
//         // retrieve pipeline package.
//         if newPipeline.DefaultVersion == nil {
//                 newPipeline.DefaultVersion = &amp;model.PipelineVersion{
//                         Name:          newPipeline.Name,
//                         Parameters:    newPipeline.Parameters,
//                         Status:        model.PipelineVersionCreating,
//                         CodeSourceUrl: ""}
//         }
//         newPipeline.DefaultVersion.CreatedAtInSec = now
//         newPipeline.DefaultVersion.PipelineId = id.String()
//         newPipeline.DefaultVersion.UUID = id.String()
//         sqlPipelineVersions, argsPipelineVersions, err := sq.
//                 Insert("pipeline_versions").
//                 SetMap(
//                         sq.Eq{
//                                 "UUID":           newPipeline.DefaultVersion.UUID,
//                                 "CreatedAtInSec": newPipeline.DefaultVersion.CreatedAtInSec,
//                                 "Name":           newPipeline.DefaultVersion.Name,
//                                 "Parameters":     newPipeline.DefaultVersion.Parameters,
//                                 "Status":         string(newPipeline.DefaultVersion.Status),
//                                 "PipelineId":     newPipeline.UUID,
//                                 "Description":    newPipeline.DefaultVersion.Description,
//                                 "CodeSourceUrl":  newPipeline.DefaultVersion.CodeSourceUrl}).
//                 ToSql()
//         if err != nil {
//                 return nil, util.NewInternalServerError(err,
//                         "PipelineStore (v1beta1): Failed to create query to insert pipeline version to pipeline_versions table: %v", err.Error())
//         }
//         // In a transaction, we insert into both pipelines and pipeline_versions.
//         tx, err := s.db.Begin()
//         if err != nil {
//                 return nil, util.NewInternalServerError(err,
//                         "PipelineStore (v1beta1): Failed to start a transaction to create a new pipeline: %v",
//                         err.Error())
//         }
//         _, err = tx.Exec(sql, args...)
//         if err != nil {
//                 if s.db.IsDuplicateError(err) {
//                         tx.Rollback()
//                         return nil, util.NewAlreadyExistError(
//                                 "PipelineStore (v1beta1): Failed to create a new pipeline. The name %v already exist. Please specify a new name.", p.Name)
//                 }
//                 tx.Rollback()
//                 return nil, util.NewInternalServerError(err, "PipelineStore (v1beta1): Failed to add pipeline to pipeline table: %v",
//                         err.Error())
//         }
//         _, err = tx.Exec(sqlPipelineVersions, argsPipelineVersions...)
//         if err != nil {
//                 if s.db.IsDuplicateError(err) {
//                         tx.Rollback()
//                         return nil, util.NewAlreadyExistError(
//                                 `PipelineStore (v1beta1): Failed to create a new pipeline version. The name %v already
//                                 exist. Please specify a new name.`, p.DefaultVersion.Name)
//                 }
//                 tx.Rollback()
//                 return nil, util.NewInternalServerError(err,
//                         "PipelineStore (v1beta1): Failed to add pipeline version to pipeline_versions table: %v",
//                         err.Error())
//         }
//         if err := tx.Commit(); err != nil {
//                 return nil, util.NewInternalServerError(err,
//                         `PipelineStore (v1beta1): Failed to update pipelines and pipeline_versions in a
//                         transaction: %v`, err.Error())
//         }
//         return &amp;newPipeline, nil
// }
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2018-2022 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "database/sql"

        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/kubeflow/pipelines/backend/src/apiserver/model"
        "github.com/kubeflow/pipelines/backend/src/common/util"
        "k8s.io/apimachinery/pkg/util/json"
)

var resourceReferenceColumns = []string{"ResourceUUID", "ResourceType", "ReferenceUUID",
        "ReferenceName", "ReferenceType", "Relationship", "Payload"}

type ResourceReferenceStoreInterface interface {
        // Retrieve the resource reference for a given resource id, type and a reference type.
        GetResourceReference(resourceId string, resourceType model.ResourceType,
                referenceType model.ResourceType) (*model.ResourceReference, error)
}

type ResourceReferenceStore struct {
        db *DB
}

// Create a resource reference.
// This is always in company with creating a parent resource so a transaction is needed as input.
func (s *ResourceReferenceStore) CreateResourceReferences(tx *sql.Tx, refs []*model.ResourceReference) error <span class="cov8" title="1">{
        if len(refs) &gt; 0 </span><span class="cov8" title="1">{
                resourceRefSqlBuilder := sq.
                        Insert("resource_references").
                        Columns("ResourceUUID", "ResourceType", "ReferenceUUID", "ReferenceName", "ReferenceType", "Relationship", "Payload")
                for _, ref := range refs </span><span class="cov8" title="1">{
                        if !s.checkReferenceExist(tx, ref.ReferenceUUID, ref.ReferenceType) </span><span class="cov8" title="1">{
                                return util.NewResourceNotFoundError(string(ref.ReferenceType), ref.ReferenceUUID)
                        }</span>
                        <span class="cov8" title="1">payload, err := json.Marshal(ref)
                        if err != nil </span><span class="cov0" title="0">{
                                return util.NewInternalServerError(err, "Failed to stream resource reference model to a json payload")
                        }</span>
                        <span class="cov8" title="1">resourceRefSqlBuilder = resourceRefSqlBuilder.Values(
                                ref.ResourceUUID, ref.ResourceType, ref.ReferenceUUID, ref.ReferenceName, ref.ReferenceType, ref.Relationship, string(payload))</span>
                }
                <span class="cov8" title="1">refSql, refArgs, err := resourceRefSqlBuilder.ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        return util.NewInternalServerError(err, "Failed to create query to store resource references.")
                }</span>
                <span class="cov8" title="1">_, err = tx.Exec(refSql, refArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        return util.NewInternalServerError(err, "Failed to store resource references.")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ResourceReferenceStore) checkReferenceExist(tx *sql.Tx, referenceId string, referenceType model.ResourceType) bool <span class="cov8" title="1">{
        var selectBuilder sq.SelectBuilder
        switch referenceType </span>{
        case model.JobResourceType:<span class="cov0" title="0">
                selectBuilder = sq.Select("1").From("jobs").Where(sq.Eq{"uuid": referenceId})</span>
        case model.ExperimentResourceType:<span class="cov8" title="1">
                selectBuilder = sq.Select("1").From("experiments").Where(sq.Eq{"uuid": referenceId})</span>
        case model.PipelineVersionResourceType:<span class="cov0" title="0">
                selectBuilder = sq.Select("1").From("pipeline_versions").Where(sq.Eq{"uuid": referenceId})</span>
        case model.NamespaceResourceType:<span class="cov0" title="0">
                // This function is called to check the data validity when the data are transformed according to the DB schema.
                // Since there is not a separate table to store the namespace data, thus always returning true.
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
        <span class="cov8" title="1">query, args, err := selectBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">var exists bool
        err = tx.QueryRow(fmt.Sprintf("SELECT exists (%s)", query), args...).Scan(&amp;exists)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return exists</span>
}

// Delete all resource references for a specific resource.
// This is always in company with creating a parent resource so a transaction is needed as input.
func (s *ResourceReferenceStore) DeleteResourceReferences(tx *sql.Tx, id string, resourceType model.ResourceType) error <span class="cov8" title="1">{
        refSql, refArgs, err := sq.
                Delete("resource_references").
                Where(sq.Or{
                        sq.Eq{"ResourceUUID": id, "ResourceType": resourceType},
                        sq.Eq{"ReferenceUUID": id, "ReferenceType": resourceType}}).
                ToSql()
        _, err = tx.Exec(refSql, refArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "Failed to delete resource references for %s %s", resourceType, id)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *ResourceReferenceStore) GetResourceReference(resourceId string, resourceType model.ResourceType,
        referenceType model.ResourceType) (*model.ResourceReference, error) <span class="cov8" title="1">{
        sql, args, err := sq.Select(resourceReferenceColumns...).
                From("resource_references").
                Where(sq.Eq{
                        "ResourceUUID":  resourceId,
                        "ResourceType":  resourceType,
                        "ReferenceType": referenceType}).
                Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err,
                        "Failed to create query to get resource reference. "+
                                "Resource ID: %s. Resource Type: %s. Reference Type: %s", resourceId, resourceType, referenceType)
        }</span>
        <span class="cov8" title="1">row, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err,
                        "Failed to get resource reference. "+
                                "Resource ID: %s. Resource Type: %s. Reference Type: %s", resourceId, resourceType, referenceType)
        }</span>
        <span class="cov8" title="1">defer row.Close()
        reference, err := s.scanRows(row)
        if err != nil || len(reference) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to get resource reference: %v", err.Error())
        }</span>
        <span class="cov8" title="1">if len(reference) == 0 </span><span class="cov8" title="1">{
                return nil, util.NewResourcesNotFoundError(
                        "Resource ID: %s. Resource Type: %s. Reference Type: %s", resourceId, resourceType, referenceType)
        }</span>
        <span class="cov8" title="1">return &amp;reference[0], nil</span>
}

func (s *ResourceReferenceStore) scanRows(r *sql.Rows) ([]model.ResourceReference, error) <span class="cov8" title="1">{
        var references []model.ResourceReference
        for r.Next() </span><span class="cov8" title="1">{
                var resourceUUID, resourceType, referenceUUID, referenceName, referenceType, relationship, payload string
                err := r.Scan(
                        &amp;resourceUUID, &amp;resourceType, &amp;referenceUUID, &amp;referenceName, &amp;referenceType, &amp;relationship, &amp;payload)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">references = append(references, model.ResourceReference{
                        ResourceUUID:  resourceUUID,
                        ResourceType:  model.ResourceType(resourceType),
                        ReferenceUUID: referenceUUID,
                        ReferenceName: referenceName,
                        ReferenceType: model.ResourceType(referenceType),
                        Relationship:  model.Relationship(relationship),
                        Payload:       payload,
                })</span>
        }
        <span class="cov8" title="1">return references, nil</span>
}

func NewResourceReferenceStore(db *DB) *ResourceReferenceStore <span class="cov8" title="1">{
        return &amp;ResourceReferenceStore{db: db}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2018-2022 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "database/sql"
        "fmt"

        "github.com/pkg/errors"

        sq "github.com/Masterminds/squirrel"
        workflowapi "github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1"
        "github.com/golang/glog"

        api "github.com/kubeflow/pipelines/backend/api/v1beta1/go_client"
        "github.com/kubeflow/pipelines/backend/src/apiserver/list"
        "github.com/kubeflow/pipelines/backend/src/apiserver/model"
        "github.com/kubeflow/pipelines/backend/src/common/util"
        "k8s.io/apimachinery/pkg/util/json"
)

var runColumns = []string{"UUID", "ExperimentUUID", "DisplayName", "Name", "StorageState", "Namespace", "ServiceAccount", "Description",
        "CreatedAtInSec", "ScheduledAtInSec", "FinishedAtInSec", "Conditions", "PipelineId", "PipelineName", "PipelineSpecManifest",
        "WorkflowSpecManifest", "Parameters", "RuntimeParameters", "PipelineRoot", "pipelineRuntimeManifest", "WorkflowRuntimeManifest",
}

type RunStoreInterface interface {
        GetRun(runId string) (*model.RunDetail, error)

        ListRuns(filterContext *model.FilterContext, opts *list.Options) ([]*model.Run, int, string, error)

        // Create a run entry in the database
        CreateRun(run *model.RunDetail) (*model.RunDetail, error)

        // Update run table. Only condition and runtime manifest is allowed to be updated.
        UpdateRun(id string, condition string, finishedAtInSec int64, workflowRuntimeManifest string) (err error)

        // Archive a run
        ArchiveRun(id string) error

        // Unarchive a run
        UnarchiveRun(id string) error

        // Delete a run entry from the database
        DeleteRun(id string) error

        // Update the run table or create one if the run doesn't exist
        CreateOrUpdateRun(run *model.RunDetail) error

        // Store a new metric entry to run_metrics table.
        ReportMetric(metric *model.RunMetric) (err error)

        // Terminate a run
        TerminateRun(runId string) error
}

type RunStore struct {
        db                     *DB
        resourceReferenceStore *ResourceReferenceStore
        time                   util.TimeInterface
}

// Runs two SQL queries in a transaction to return a list of matching runs, as well as their
// total_size. The total_size does not reflect the page size, but it does reflect the number of runs
// matching the supplied filters and resource references.
func (s *RunStore) ListRuns(
        filterContext *model.FilterContext, opts *list.Options) ([]*model.Run, int, string, error) <span class="cov8" title="1">{
        errorF := func(err error) ([]*model.Run, int, string, error) </span><span class="cov8" title="1">{
                return nil, 0, "", util.NewInternalServerError(err, "Failed to list runs: %v", err)
        }</span>

        <span class="cov8" title="1">rowsSql, rowsArgs, err := s.buildSelectRunsQuery(false, opts, filterContext)
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>

        <span class="cov8" title="1">sizeSql, sizeArgs, err := s.buildSelectRunsQuery(true, opts, filterContext)
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>

        // Use a transaction to make sure we're returning the total_size of the same rows queried
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                glog.Error("Failed to start transaction to list runs")
                return errorF(err)
        }</span>

        <span class="cov8" title="1">rows, err := tx.Query(rowsSql, rowsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>
        <span class="cov8" title="1">runDetails, err := s.scanRowsToRunDetails(rows)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">rows.Close()

        sizeRow, err := tx.Query(sizeSql, sizeArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">total_size, err := list.ScanRowToTotalSize(sizeRow)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">sizeRow.Close()

        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Error("Failed to commit transaction to list runs")
                return errorF(err)
        }</span>

        <span class="cov8" title="1">var runs []*model.Run
        for _, rd := range runDetails </span><span class="cov8" title="1">{
                r := rd.Run
                runs = append(runs, &amp;r)
        }</span>

        <span class="cov8" title="1">if len(runs) &lt;= opts.PageSize </span><span class="cov8" title="1">{
                return runs, total_size, "", nil
        }</span>

        <span class="cov8" title="1">npt, err := opts.NextPageToken(runs[opts.PageSize])
        return runs[:opts.PageSize], total_size, npt, err</span>
}

func (s *RunStore) buildSelectRunsQuery(selectCount bool, opts *list.Options,
        filterContext *model.FilterContext) (string, []interface{}, error) <span class="cov8" title="1">{

        var filteredSelectBuilder sq.SelectBuilder
        var err error

        refKey := filterContext.ReferenceKey
        if refKey != nil &amp;&amp; refKey.Type == model.ExperimentResourceType </span><span class="cov8" title="1">{
                // for performance reasons need to special treat experiment ID filter on runs
                // currently only the run table have experiment UUID column
                filteredSelectBuilder, err = list.FilterOnExperiment("run_details", runColumns,
                        selectCount, refKey.ID)
        }</span> else<span class="cov8" title="1"> if refKey != nil &amp;&amp; refKey.Type == model.NamespaceResourceType </span><span class="cov0" title="0">{
                filteredSelectBuilder, err = list.FilterOnNamespace("run_details", runColumns,
                        selectCount, refKey.ID)
        }</span> else<span class="cov8" title="1"> {
                filteredSelectBuilder, err = list.FilterOnResourceReference("run_details", runColumns,
                        model.RunResourceType, selectCount, filterContext)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", nil, util.NewInternalServerError(err, "Failed to list runs: %v", err)
        }</span>

        <span class="cov8" title="1">sqlBuilder := opts.AddFilterToSelect(filteredSelectBuilder)

        // If we're not just counting, then also add select columns and perform a left join
        // to get resource reference information. Also add pagination.
        if !selectCount </span><span class="cov8" title="1">{
                sqlBuilder = s.AddSortByRunMetricToSelect(sqlBuilder, opts)
                sqlBuilder = opts.AddPaginationToSelect(sqlBuilder)
                sqlBuilder = s.addMetricsAndResourceReferences(sqlBuilder, opts)
                sqlBuilder = opts.AddSortingToSelect(sqlBuilder)
        }</span>
        <span class="cov8" title="1">sql, args, err := sqlBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, util.NewInternalServerError(err, "Failed to list runs: %v", err)
        }</span>
        <span class="cov8" title="1">return sql, args, err</span>
}

// GetRun Get the run manifest from Workflow CRD
func (s *RunStore) GetRun(runId string) (*model.RunDetail, error) <span class="cov8" title="1">{
        sql, args, err := s.addMetricsAndResourceReferences(
                sq.Select(runColumns...).
                        From("run_details").
                        Where(sq.Eq{"UUID": runId}).
                        Limit(1), nil).
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to get run: %v", err.Error())
        }</span>
        <span class="cov8" title="1">r, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "Failed to get run: %v", err.Error())
        }</span>
        <span class="cov8" title="1">defer r.Close()
        runs, err := s.scanRowsToRunDetails(r)

        if err != nil || len(runs) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to get run: %v", err.Error())
        }</span>
        <span class="cov8" title="1">if len(runs) == 0 </span><span class="cov8" title="1">{
                return nil, util.NewResourceNotFoundError("Run", fmt.Sprint(runId))
        }</span>
        <span class="cov8" title="1">if runs[0].WorkflowRuntimeManifest == "" &amp;&amp; runs[0].WorkflowSpecManifest != "" </span><span class="cov0" title="0">{
                // This can only happen when workflow reporting is failed.
                return nil, util.NewResourceNotFoundError("Failed to get run: %s", runId)
        }</span>
        <span class="cov8" title="1">return runs[0], nil</span>
}

// Apply func f to every string in a given string slice.
func Map(vs []string, f func(string) string) []string <span class="cov8" title="1">{
        vsm := make([]string, len(vs))
        for i, v := range vs </span><span class="cov8" title="1">{
                vsm[i] = f(v)
        }</span>
        <span class="cov8" title="1">return vsm</span>
}

func (s *RunStore) addMetricsAndResourceReferences(filteredSelectBuilder sq.SelectBuilder, opts *list.Options) sq.SelectBuilder <span class="cov8" title="1">{
        var r model.Run
        resourceRefConcatQuery := s.db.Concat([]string{`"["`, s.db.GroupConcat("rr.Payload", ","), `"]"`}, "")
        columnsAfterJoiningResourceReferences := append(
                Map(runColumns, func(column string) string </span><span class="cov8" title="1">{ return "rd." + column }</span>), // Add prefix "rd." to runColumns
                resourceRefConcatQuery+" AS refs")
        <span class="cov8" title="1">if opts != nil &amp;&amp; !r.IsRegularField(opts.SortByFieldName) </span><span class="cov8" title="1">{
                columnsAfterJoiningResourceReferences = append(columnsAfterJoiningResourceReferences, "rd."+opts.SortByFieldName)
        }</span>
        <span class="cov8" title="1">subQ := sq.
                Select(columnsAfterJoiningResourceReferences...).
                FromSelect(filteredSelectBuilder, "rd").
                LeftJoin("resource_references AS rr ON rr.ResourceType='Run' AND rd.UUID=rr.ResourceUUID").
                GroupBy("rd.UUID")

        // TODO(jingzhang36): address the case where some runs don't have the metric used in order by.
        metricConcatQuery := s.db.Concat([]string{`"["`, s.db.GroupConcat("rm.Payload", ","), `"]"`}, "")
        columnsAfterJoiningRunMetrics := append(
                Map(runColumns, func(column string) string </span><span class="cov8" title="1">{ return "subq." + column }</span>), // Add prefix "subq." to runColumns
                "subq.refs",
                metricConcatQuery+" AS metrics")
        <span class="cov8" title="1">return sq.
                Select(columnsAfterJoiningRunMetrics...).
                FromSelect(subQ, "subq").
                LeftJoin("run_metrics AS rm ON subq.UUID=rm.RunUUID").
                GroupBy("subq.UUID")</span>
}

func (s *RunStore) scanRowsToRunDetails(rows *sql.Rows) ([]*model.RunDetail, error) <span class="cov8" title="1">{
        var runs []*model.RunDetail
        for rows.Next() </span><span class="cov8" title="1">{
                var uuid, experimentUUID, displayName, name, storageState, namespace, serviceAccount, description, pipelineId,
                        pipelineName, pipelineSpecManifest, workflowSpecManifest, parameters, conditions, pipelineRuntimeManifest,
                        workflowRuntimeManifest string
                var createdAtInSec, scheduledAtInSec, finishedAtInSec int64
                var metricsInString, resourceReferencesInString, runtimeParameters, pipelineRoot sql.NullString
                err := rows.Scan(
                        &amp;uuid,
                        &amp;experimentUUID,
                        &amp;displayName,
                        &amp;name,
                        &amp;storageState,
                        &amp;namespace,
                        &amp;serviceAccount,
                        &amp;description,
                        &amp;createdAtInSec,
                        &amp;scheduledAtInSec,
                        &amp;finishedAtInSec,
                        &amp;conditions,
                        &amp;pipelineId,
                        &amp;pipelineName,
                        &amp;pipelineSpecManifest,
                        &amp;workflowSpecManifest,
                        &amp;parameters,
                        &amp;runtimeParameters,
                        &amp;pipelineRoot,
                        &amp;pipelineRuntimeManifest,
                        &amp;workflowRuntimeManifest,
                        &amp;resourceReferencesInString,
                        &amp;metricsInString,
                )
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Failed to scan row: %v", err)
                        return runs, nil
                }</span>
                <span class="cov8" title="1">metrics, err := parseMetrics(metricsInString)
                if err != nil </span><span class="cov8" title="1">{
                        glog.Errorf("Failed to parse metrics (%v) from DB: %v", metricsInString, err)
                        // Skip the error to allow user to get runs even when metrics data
                        // are invalid.
                        metrics = []*model.RunMetric{}
                }</span>
                <span class="cov8" title="1">resourceReferences, err := parseResourceReferences(resourceReferencesInString)
                if err != nil </span><span class="cov0" title="0">{
                        // throw internal exception if failed to parse the resource reference.
                        return nil, util.NewInternalServerError(err, "Failed to parse resource reference.")
                }</span>
                <span class="cov8" title="1">runtimeConfig := parseRuntimeConfig(runtimeParameters, pipelineRoot)
                runs = append(runs, &amp;model.RunDetail{Run: model.Run{
                        UUID:               uuid,
                        ExperimentUUID:     experimentUUID,
                        DisplayName:        displayName,
                        Name:               name,
                        StorageState:       storageState,
                        Namespace:          namespace,
                        ServiceAccount:     serviceAccount,
                        Description:        description,
                        CreatedAtInSec:     createdAtInSec,
                        ScheduledAtInSec:   scheduledAtInSec,
                        FinishedAtInSec:    finishedAtInSec,
                        Conditions:         conditions,
                        Metrics:            metrics,
                        ResourceReferences: resourceReferences,
                        PipelineSpec: model.PipelineSpec{
                                PipelineId:           pipelineId,
                                PipelineName:         pipelineName,
                                PipelineSpecManifest: pipelineSpecManifest,
                                WorkflowSpecManifest: workflowSpecManifest,
                                Parameters:           parameters,
                                RuntimeConfig:        runtimeConfig,
                        },
                },
                        PipelineRuntime: model.PipelineRuntime{
                                PipelineRuntimeManifest: pipelineRuntimeManifest,
                                WorkflowRuntimeManifest: workflowRuntimeManifest}})</span>
        }
        <span class="cov8" title="1">return runs, nil</span>
}

func parseMetrics(metricsInString sql.NullString) ([]*model.RunMetric, error) <span class="cov8" title="1">{
        if !metricsInString.Valid </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var metrics []*model.RunMetric
        if err := json.Unmarshal([]byte(metricsInString.String), &amp;metrics); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed unmarshal metrics '%s'. error: %v", metricsInString.String, err)
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}

func parseRuntimeConfig(runtimeParameters sql.NullString, pipelineRoot sql.NullString) model.RuntimeConfig <span class="cov8" title="1">{
        var runtimeParametersString, pipelineRootString string
        if runtimeParameters.Valid </span><span class="cov8" title="1">{
                runtimeParametersString = runtimeParameters.String
        }</span>
        <span class="cov8" title="1">if pipelineRoot.Valid </span><span class="cov8" title="1">{
                pipelineRootString = pipelineRoot.String
        }</span>
        <span class="cov8" title="1">return model.RuntimeConfig{Parameters: runtimeParametersString, PipelineRoot: pipelineRootString}</span>
}

func parseResourceReferences(resourceRefString sql.NullString) ([]*model.ResourceReference, error) <span class="cov8" title="1">{
        if !resourceRefString.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var refs []*model.ResourceReference
        if err := json.Unmarshal([]byte(resourceRefString.String), &amp;refs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed unmarshal resource references '%s'. error: %v", resourceRefString.String, err)
        }</span>
        <span class="cov8" title="1">return refs, nil</span>
}

func (s *RunStore) CreateRun(r *model.RunDetail) (*model.RunDetail, error) <span class="cov8" title="1">{
        if r.StorageState == "" </span><span class="cov8" title="1">{
                r.StorageState = api.Run_STORAGESTATE_AVAILABLE.String()
        }</span> else<span class="cov8" title="1"> if r.StorageState != api.Run_STORAGESTATE_AVAILABLE.String() &amp;&amp;
                r.StorageState != api.Run_STORAGESTATE_ARCHIVED.String() </span><span class="cov8" title="1">{
                return nil, util.NewInvalidInputError("Invalid value for StorageState field: %q.", r.StorageState)
        }</span>

        <span class="cov8" title="1">runSql, runArgs, err := sq.
                Insert("run_details").
                SetMap(sq.Eq{
                        "UUID":                    r.UUID,
                        "ExperimentUUID":          r.ExperimentUUID,
                        "DisplayName":             r.DisplayName,
                        "Name":                    r.Name,
                        "StorageState":            r.StorageState,
                        "Namespace":               r.Namespace,
                        "ServiceAccount":          r.ServiceAccount,
                        "Description":             r.Description,
                        "CreatedAtInSec":          r.CreatedAtInSec,
                        "ScheduledAtInSec":        r.ScheduledAtInSec,
                        "FinishedAtInSec":         r.FinishedAtInSec,
                        "Conditions":              r.Conditions,
                        "WorkflowRuntimeManifest": r.WorkflowRuntimeManifest,
                        "PipelineRuntimeManifest": r.PipelineRuntimeManifest,
                        "PipelineId":              r.PipelineId,
                        "PipelineName":            r.PipelineName,
                        "PipelineSpecManifest":    r.PipelineSpecManifest,
                        "WorkflowSpecManifest":    r.WorkflowSpecManifest,
                        "Parameters":              r.Parameters,
                        "RuntimeParameters":       r.PipelineSpec.RuntimeConfig.Parameters,
                        "PipelineRoot":            r.PipelineSpec.RuntimeConfig.PipelineRoot,
                }).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to create query to store run to run table: '%v/%v",
                        r.Namespace, r.Name)
        }</span>

        // Use a transaction to make sure both run and its resource references are stored.
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return nil, util.NewInternalServerError(err, "Failed to create a new transaction to create run.")
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec(runSql, runArgs...)
        if err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return nil, util.NewInternalServerError(err, "Failed to store run %v to table", r.Name)
        }</span>

        <span class="cov8" title="1">err = s.resourceReferenceStore.CreateResourceReferences(tx, r.ResourceReferences)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, util.NewInternalServerError(err, "Failed to store resource references to table for run %v ", r.Name)
        }</span>
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, util.NewInternalServerError(err, "Failed to store run %v and its resource references to table", r.Name)
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (s *RunStore) UpdateRun(runID string, condition string, finishedAtInSec int64, workflowRuntimeManifest string) (err error) <span class="cov8" title="1">{
        tx, err := s.db.DB.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "transaction creation failed")
        }</span>

        <span class="cov8" title="1">sql, args, err := sq.
                Update("run_details").
                SetMap(sq.Eq{
                        "Conditions":              condition,
                        "FinishedAtInSec":         finishedAtInSec,
                        "WorkflowRuntimeManifest": workflowRuntimeManifest}).
                Where(sq.Eq{"UUID": runID}).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err,
                        "Failed to create query to update run %s. error: '%v'", runID, err.Error())
        }</span>
        <span class="cov8" title="1">result, err := tx.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err,
                        "Failed to update run %s. error: '%v'", runID, err.Error())
        }</span>
        <span class="cov8" title="1">r, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err,
                        "Failed to update run %s. error: '%v'", runID, err.Error())
        }</span>
        <span class="cov8" title="1">if r &gt; 1 </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(errors.New("Failed to update run"), "Failed to update run %s. More than 1 rows affected", runID)
        }</span> else<span class="cov8" title="1"> if r == 0 </span><span class="cov8" title="1">{
                tx.Rollback()
                return util.Wrap(util.NewResourceNotFoundError("Run", fmt.Sprint(runID)), "Failed to update run")
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err, "failed to commit transaction for run %s", runID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *RunStore) CreateOrUpdateRun(runDetail *model.RunDetail) error <span class="cov8" title="1">{
        _, createError := s.CreateRun(runDetail)
        if createError == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">updateError := s.UpdateRun(runDetail.UUID, runDetail.Conditions, runDetail.FinishedAtInSec, runDetail.WorkflowRuntimeManifest)
        if updateError != nil </span><span class="cov8" title="1">{
                return util.Wrap(updateError, fmt.Sprintf(
                        "Error while creating or updating run for workflow: '%v/%v'. Create error: '%v'. Update error: '%v'",
                        runDetail.Namespace, runDetail.Name, createError.Error(), updateError.Error()))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *RunStore) ArchiveRun(runId string) error <span class="cov8" title="1">{
        sql, args, err := sq.
                Update("run_details").
                SetMap(sq.Eq{
                        "StorageState": api.Run_STORAGESTATE_ARCHIVED.String(),
                }).
                Where(sq.Eq{"UUID": runId}).
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to archive run %s. error: '%v'", runId, err.Error())
        }</span>

        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err,
                        "Failed to archive run %s. error: '%v'", runId, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *RunStore) UnarchiveRun(runId string) error <span class="cov8" title="1">{
        sql, args, err := sq.
                Update("run_details").
                SetMap(sq.Eq{
                        "StorageState": api.Run_STORAGESTATE_AVAILABLE.String(),
                }).
                Where(sq.Eq{"UUID": runId}).
                ToSql()

        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to unarchive run %s. error: '%v'", runId, err.Error())
        }</span>

        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err,
                        "Failed to unarchive run %s. error: '%v'", runId, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *RunStore) DeleteRun(id string) error <span class="cov8" title="1">{
        runSql, runArgs, err := sq.Delete("run_details").Where(sq.Eq{"UUID": id}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to create query to delete run: %s", id)
        }</span>
        // Use a transaction to make sure both run and its resource references are stored.
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return util.NewInternalServerError(err, "Failed to create a new transaction to delete run.")
        }</span>
        <span class="cov8" title="1">_, err = tx.Exec(runSql, runArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to delete run %s from table", id)
        }</span>
        <span class="cov8" title="1">err = s.resourceReferenceStore.DeleteResourceReferences(tx, id, model.RunResourceType)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to delete resource references from table for run %v ", id)
        }</span>
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return util.NewInternalServerError(err, "Failed to delete run %v and its resource references from table", id)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ReportMetric inserts a new metric to run_metrics table. Conflicting metrics
// are ignored.
func (s *RunStore) ReportMetric(metric *model.RunMetric) (err error) <span class="cov8" title="1">{
        payloadBytes, err := json.Marshal(metric)
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "failed to marshal metric to json: %+v", metric)
        }</span>
        <span class="cov8" title="1">sql, args, err := sq.
                Insert("run_metrics").
                SetMap(sq.Eq{
                        "RunUUID":     metric.RunUUID,
                        "NodeID":      metric.NodeID,
                        "Name":        metric.Name,
                        "NumberValue": metric.NumberValue,
                        "Format":      metric.Format,
                        "Payload":     string(payloadBytes)}).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "failed to create query for inserting metric: %+v", metric)
        }</span>
        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov8" title="1">{
                if s.db.IsDuplicateError(err) </span><span class="cov8" title="1">{
                        return util.NewAlreadyExistError(
                                "same metric has been reported before: %s/%s", metric.NodeID, metric.Name)
                }</span>
                <span class="cov0" title="0">return util.NewInternalServerError(err, "failed to insert metric: %v", metric)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *RunStore) toListableModels(runs []model.RunDetail) []model.ListableDataModel <span class="cov0" title="0">{
        models := make([]model.ListableDataModel, len(runs))
        for i := range models </span><span class="cov0" title="0">{
                models[i] = runs[i].Run
        }</span>
        <span class="cov0" title="0">return models</span>
}

func (s *RunStore) toRunMetadatas(models []model.ListableDataModel) []model.Run <span class="cov0" title="0">{
        runMetadatas := make([]model.Run, len(models))
        for i := range models </span><span class="cov0" title="0">{
                runMetadatas[i] = models[i].(model.Run)
        }</span>
        <span class="cov0" title="0">return runMetadatas</span>
}

// NewRunStore creates a new RunStore.
func NewRunStore(db *DB, time util.TimeInterface) *RunStore <span class="cov8" title="1">{
        return &amp;RunStore{
                db:                     db,
                resourceReferenceStore: NewResourceReferenceStore(db),
                time:                   time,
        }
}</span>

func (s *RunStore) TerminateRun(runId string) error <span class="cov8" title="1">{
        result, err := s.db.Exec(`
                UPDATE run_details
                SET Conditions = ?
                WHERE UUID = ? AND (Conditions = ? OR Conditions = ? OR Conditions = ?)`,
                model.RunTerminatingConditions, runId, string(workflowapi.NodeRunning), string(workflowapi.NodePending), "")

        if err != nil </span><span class="cov0" title="0">{
                return util.NewInternalServerError(err,
                        "Failed to terminate run %s. error: '%v'", runId, err.Error())
        }</span>

        <span class="cov8" title="1">if r, _ := result.RowsAffected(); r != 1 </span><span class="cov8" title="1">{
                return util.NewInvalidInputError("Failed to terminate run %s. Row not found.", runId)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Add a metric as a new field to the select clause by join the passed-in SQL query with run_metrics table.
// With the metric as a field in the select clause enable sorting on this metric afterwards.
// TODO(jingzhang36): example of resulting SQL query and explanation for it.
func (s *RunStore) AddSortByRunMetricToSelect(sqlBuilder sq.SelectBuilder, opts *list.Options) sq.SelectBuilder <span class="cov8" title="1">{
        var r model.Run
        if r.IsRegularField(opts.SortByFieldName) </span><span class="cov8" title="1">{
                return sqlBuilder
        }</span>
        // TODO(jingzhang36): address the case where runs doesn't have the specified metric.
        <span class="cov8" title="1">return sq.
                Select("selected_runs.*, run_metrics.numbervalue as "+opts.SortByFieldName).
                FromSelect(sqlBuilder, "selected_runs").
                LeftJoin("run_metrics ON selected_runs.uuid=run_metrics.runuuid AND run_metrics.name='" + opts.SortByFieldName + "'")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
        "database/sql"

        "github.com/kubeflow/pipelines/backend/src/common/util"
)

func NullStringToPointer(ns sql.NullString) *string <span class="cov8" title="1">{
        if ns.Valid </span><span class="cov8" title="1">{
                return util.StringPointer(ns.String)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func NullInt64ToPointer(ni sql.NullInt64) *int64 <span class="cov8" title="1">{
        if ni.Valid </span><span class="cov8" title="1">{
                return util.Int64Pointer(ni.Int64)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func PointerToNullString(sp *string) sql.NullString <span class="cov8" title="1">{
        if sp == nil </span><span class="cov8" title="1">{
                return sql.NullString{}
        }</span>
        <span class="cov8" title="1">return sql.NullString{
                String: *sp,
                Valid:  true,
        }</span>
}

func PointerToNullInt64(ip *int64) sql.NullInt64 <span class="cov8" title="1">{
        if ip == nil </span><span class="cov8" title="1">{
                return sql.NullInt64{}
        }</span>
        <span class="cov8" title="1">return sql.NullInt64{
                Int64: *ip,
                Valid: true,
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2021-2022 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.package storage

package storage

import (
        "database/sql"
        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/golang/glog"
        "github.com/kubeflow/pipelines/backend/src/apiserver/list"
        "github.com/kubeflow/pipelines/backend/src/apiserver/model"
        "github.com/kubeflow/pipelines/backend/src/common/util"
)

const table_name = "tasks"

var (
        taskColumns = []string{
                "UUID",
                "Namespace",
                "PipelineName",
                "RunUUID",
                "MLMDExecutionID",
                "CreatedTimestamp",
                "FinishedTimestamp",
                "Fingerprint",
        }
)

type TaskStoreInterface interface {
        // Create a task entry in the database
        CreateTask(task *model.Task) (*model.Task, error)

        ListTasks(filterContext *model.FilterContext, opts *list.Options) ([]*model.Task, int, string, error)

        GetTask(id string) (*model.Task, error)
}

type TaskStore struct {
        db   *DB
        time util.TimeInterface
        uuid util.UUIDGeneratorInterface
}

// NewTaskStore creates a new TaskStore.
func NewTaskStore(db *DB, time util.TimeInterface, uuid util.UUIDGeneratorInterface) *TaskStore <span class="cov8" title="1">{
        return &amp;TaskStore{
                db:   db,
                time: time,
                uuid: uuid,
        }
}</span>

func (s *TaskStore) CreateTask(task *model.Task) (*model.Task, error) <span class="cov8" title="1">{
        // Set up UUID for task.
        newTask := *task
        id, err := s.uuid.NewRandom()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to create an task id.")
        }</span>
        <span class="cov8" title="1">newTask.UUID = id.String()

        sql, args, err := sq.
                Insert(table_name).
                SetMap(sq.Eq{
                        "UUID":              newTask.UUID,
                        "Namespace":         newTask.Namespace,
                        "PipelineName":      newTask.PipelineName,
                        "RunUUID":           newTask.RunUUID,
                        "MLMDExecutionID":   newTask.MLMDExecutionID,
                        "CreatedTimestamp":  newTask.CreatedTimestamp,
                        "FinishedTimestamp": newTask.FinishedTimestamp,
                        "Fingerprint":       newTask.Fingerprint,
                }).
                ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to create query to insert task to task table: %v",
                        err.Error())
        }</span>
        <span class="cov8" title="1">_, err = s.db.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to add task to task table: %v",
                        err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;newTask, nil</span>
}

func (s *TaskStore) scanRows(rows *sql.Rows) ([]*model.Task, error) <span class="cov8" title="1">{
        var tasks []*model.Task
        for rows.Next() </span><span class="cov8" title="1">{
                var uuid, namespace, pipelineName, runUUID, mlmdExecutionID, fingerprint string
                var createdTimestamp, finishedTimestamp int64
                err := rows.Scan(&amp;uuid, &amp;namespace, &amp;pipelineName, &amp;runUUID, &amp;mlmdExecutionID, &amp;createdTimestamp, &amp;finishedTimestamp, &amp;fingerprint)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("scan error is %v", err)
                        return tasks, err
                }</span>
                <span class="cov8" title="1">task := &amp;model.Task{
                        UUID:              uuid,
                        Namespace:         namespace,
                        PipelineName:      pipelineName,
                        RunUUID:           runUUID,
                        MLMDExecutionID:   mlmdExecutionID,
                        CreatedTimestamp:  createdTimestamp,
                        FinishedTimestamp: finishedTimestamp,
                        Fingerprint:       fingerprint,
                }
                tasks = append(tasks, task)</span>
        }
        <span class="cov8" title="1">return tasks, nil</span>
}

// Runs two SQL queries in a transaction to return a list of matching experiments, as well as their
// total_size. The total_size does not reflect the page size.
func (s *TaskStore) ListTasks(filterContext *model.FilterContext, opts *list.Options) ([]*model.Task, int, string, error) <span class="cov8" title="1">{
        errorF := func(err error) ([]*model.Task, int, string, error) </span><span class="cov0" title="0">{
                return nil, 0, "", util.NewInternalServerError(err, "Failed to list tasks: %v", err)
        }</span>

        // SQL for getting the filtered and paginated rows
        <span class="cov8" title="1">sqlBuilder := sq.Select(taskColumns...).From("tasks")
        if filterContext.ReferenceKey != nil &amp;&amp; filterContext.ReferenceKey.Type == model.PipelineResourceType </span><span class="cov8" title="1">{
                sqlBuilder = sqlBuilder.Where(sq.Eq{"PipelineName": filterContext.ReferenceKey.ID})
        }</span>
        <span class="cov8" title="1">sqlBuilder = opts.AddFilterToSelect(sqlBuilder)

        rowsSql, rowsArgs, err := opts.AddPaginationToSelect(sqlBuilder).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>

        // SQL for getting total size. This matches the query to get all the rows above, in order
        // to do the same filter, but counts instead of scanning the rows.
        <span class="cov8" title="1">sqlBuilder = sq.Select("count(*)").From("tasks")
        if filterContext.ReferenceKey != nil &amp;&amp; filterContext.ReferenceKey.Type == model.PipelineResourceType </span><span class="cov8" title="1">{
                sqlBuilder = sqlBuilder.Where(sq.Eq{"PipelineName": filterContext.ReferenceKey.ID})
        }</span>
        <span class="cov8" title="1">sizeSql, sizeArgs, err := opts.AddFilterToSelect(sqlBuilder).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return errorF(err)
        }</span>

        // Use a transaction to make sure we're returning the total_size of the same rows queried
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("Failed to start transaction to list tasks")
                return errorF(err)
        }</span>

        <span class="cov8" title="1">rows, err := tx.Query(rowsSql, rowsArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">exps, err := s.scanRows(rows)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">rows.Close()

        sizeRow, err := tx.Query(sizeSql, sizeArgs...)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">total_size, err := list.ScanRowToTotalSize(sizeRow)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return errorF(err)
        }</span>
        <span class="cov8" title="1">sizeRow.Close()

        err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("Failed to commit transaction to list experiments")
                return errorF(err)
        }</span>

        <span class="cov8" title="1">if len(exps) &lt;= opts.PageSize </span><span class="cov8" title="1">{
                return exps, total_size, "", nil
        }</span>

        <span class="cov8" title="1">npt, err := opts.NextPageToken(exps[opts.PageSize])
        return exps[:opts.PageSize], total_size, npt, err</span>
}

func (s *TaskStore) GetTask(id string) (*model.Task, error) <span class="cov0" title="0">{
        sql, args, err := sq.
                Select(taskColumns...).
                From("tasks").
                Where(sq.Eq{"tasks.uuid": id}).
                Limit(1).ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to create query to get task: %v", err.Error())
        }</span>
        <span class="cov0" title="0">r, err := s.db.Query(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to get task: %v", err.Error())
        }</span>
        <span class="cov0" title="0">defer r.Close()
        tasks, err := s.scanRows(r)

        if err != nil || len(tasks) &gt; 1 </span><span class="cov0" title="0">{
                return nil, util.NewInternalServerError(err, "Failed to get pipeline: %v", err.Error())
        }</span>
        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                return nil, util.NewResourceNotFoundError("task", fmt.Sprint(id))
        }</span>
        <span class="cov0" title="0">return tasks[0], nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
