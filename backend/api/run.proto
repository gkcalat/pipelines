// Copyright 2018 The Kubeflow Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

option go_package = "github.com/kubeflow/pipelines/backend/api/go_client";
package api;

import "backend/api/error.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "backend/api/pipeline_spec.proto";
import "backend/api/resource_reference.proto";
import "protoc-gen-swagger/options/annotations.proto";
import "backend/api/temp/metadata_store.proto";

option (grpc.gateway.protoc_gen_swagger.options.openapiv2_swagger) = {
  responses: {
    key: "default";
    value: {
      schema: {
        json_schema: {
          ref: ".api.Status";
        }
      }
    }
  }
  // Use bearer token for authorizing access to job service.
  // Kubernetes client library(https://kubernetes.io/docs/reference/using-api/client-libraries/)
  // uses bearer token as default for authorization. The section below
  // ensures security definition object is generated in the swagger definition.
  // For more details see https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
  security_definitions: {
    security: {
      key: "Bearer";
      value: {
        type: TYPE_API_KEY;
        in: IN_HEADER;
        name: "authorization";
      }
    }
  }
  security: {
    security_requirement: {
      key: "Bearer";
      value: {};
    }
  }
};


service RunService {
  // Creates a new run.
  rpc CreateRun(CreateRunRequest) returns (RunDetail) {
    option (google.api.http) = {
      post: "/apis/v1beta1/runs"
      body: "run"
    };
  }

  // Finds a specific run by ID.
  rpc GetRun(GetRunRequest) returns (RunDetail) {
    option (google.api.http) = {
      get: "/apis/v1beta1/runs/{run_id}"
    };
  }

  // Finds all runs.
  rpc ListRuns(ListRunsRequest) returns (ListRunsResponse) {
    option (google.api.http) = {
      get: "/apis/v1beta1/runs"
    };
  }

  // Archives a run.
  rpc ArchiveRun(ArchiveRunRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/apis/v1beta1/runs/{id}:archive"
    };
  }

  // Restores an archived run.
  rpc UnarchiveRun(UnarchiveRunRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/apis/v1beta1/runs/{id}:unarchive"
    };
  }

  // Deletes a run.
  rpc DeleteRun(DeleteRunRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/apis/v1beta1/runs/{id}"
    };
  }

  // ReportRunMetrics reports metrics of a run. Each metric is reported in its
  // own transaction, so this API accepts partial failures. Metric can be
  // uniquely identified by (run_id, node_id, name). Duplicate reporting will be
  // ignored by the API. First reporting wins.
  rpc ReportRunMetrics(ReportRunMetricsRequest)
      returns (ReportRunMetricsResponse) {
    option (google.api.http) = {
      post: "/apis/v1beta1/runs/{run_id}:reportMetrics"
      body: "*"
    };
  }

  // Finds a run's artifact data.
  rpc ReadArtifact(ReadArtifactRequest) returns (ReadArtifactResponse) {
    option (google.api.http) = {
      get: "/apis/v1beta1/runs/{run_id}/nodes/{node_id}/artifacts/{artifact_name}:read"
    };
  }

  // Terminates an active run.
  rpc TerminateRun(TerminateRunRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/apis/v1beta1/runs/{run_id}/terminate"
    };
  }

  // Re-initiates a failed or terminated run.
  rpc RetryRun(RetryRunRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/apis/v1beta1/runs/{run_id}/retry"
    };
  }
}

message CreateRunRequest {
  Run run = 1;
}

message GetRunRequest {
  // The ID of the run to be retrieved.
  string run_id = 1;
}

message ListRunsRequest {
  // A page token to request the next page of results. The token is acquried
  // from the nextPageToken field of the response from the previous
  // ListRuns call or can be omitted when fetching the first page.
  string page_token = 1;

  // The number of runs to be listed per page. If there are more runs than this
  // number, the response message will contain a nextPageToken field you can use
  // to fetch the next page.
  int32 page_size = 2;

  // Can be format of "field_name", "field_name asc" or "field_name desc"
  // (Example, "name asc" or "id desc"). Ascending by default.
  string sort_by = 3;

  // What resource reference to filter on.
  // E.g. If listing run for an experiment, the query string would be
  // resource_reference_key.type=EXPERIMENT&resource_reference_key.id=123
  ResourceKey resource_reference_key = 4;

  // A url-encoded, JSON-serialized Filter protocol buffer (see
  // [filter.proto](https://github.com/kubeflow/pipelines/blob/master/backend/api/filter.proto)).
  string filter = 5;
}

message TerminateRunRequest {
  // The ID of the run to be terminated.
  string run_id = 1;
}

message RetryRunRequest {
  // The ID of the run to be retried.
  string run_id = 1;
}

message ListRunsResponse {
  repeated Run runs = 1;

  // The total number of runs for the given query.
  int32 total_size = 3;

  // The token to list the next page of runs.
  string next_page_token = 2;
}

message ArchiveRunRequest {
  // The ID of the run to be archived.
  string id = 1;
}

message UnarchiveRunRequest {
  // The ID of the run to be restored.
  string id = 1;
}

message DeleteRunRequest {
  // The ID of the run to be deleted.
  string id = 1;
}

message Run {
  // Output. Unique Run ID. Generated by API server.
  string id = 1;

  // Required input field. Name provided by user,
  // or auto generated if Run is created by scheduled job. Not unique.
  string name = 2;

  // Optional input field. Describing the purpose of the run
  string description = 3;

  // Optional input field. Specify which Kubernetes service account this Run uses.
  string service_account = 4;

  // Run creation time.
  google.protobuf.Timestamp create_time = 5;

  // Run start time.
  google.protobuf.Timestamp start_time = 6;

  // Run end time.
  google.protobuf.Timestamp end_time = 7;

  // Timestamp when the Run was most recently updated.
  google.protobuf.Timestamp update_time = 8;

  // Optional input field. The ID of the Pipeline user used for this Run.
  string pipeline_id = 9;

  // Optional input field. The pipeline spec.
  google.protobuf.Struct pipeline_spec = 10;

  // The latest state of the Run.
  RunState state = 11;

  // A timestamped record of the Run state.
  message RunStatus {
    // Update time of this state.
    google.protobuf.Timestamp update_time = 1;

    // The state of the Run.
    RunState state = 2;

    // The error that occurred during the state. May be set when the state is
    // any of the non-final state (PENDING/RUNNING/CANCELLING) or FAILED state.
    // If the state is FAILED, the error here is final and not going to be
    // retried.
    // If the state is a non-final state, the error indicates a system-error
    // being retried.
    Status error = 3;
  }

  // A list of task status. This field keeps a record of task status evolving
  // over time.
  repeated RunStatus state_history = 12;

  // The error that occurred during Run execution.
  // Only populated when the Run's state is FAILED or CANCELLED.
  Status error = 13;

  // The runtime config of a Run.
  message RuntimeConfig {
    // The runtime parameters of the PipelineSpec. The parameters will be
    // used to replace the placeholders
    // at runtime.
    map<string, google.protobuf.Value> parameters = 1;

    // A path in a object store bucket which will be treated as the root
    // output directory of the pipeline. It is used by the system to
    // generate the paths of output artifacts.
    // Ref:(https://www.kubeflow.org/docs/components/pipelines/pipeline-root/)
    string pipeline_root = 2;
  }

  // Runtime config of the pipeline.
  RuntimeConfig runtime_config = 14;

  // The details of the Run.
  RunDetail run_detail = 15;

  enum StorageState {
    STORAGESTATE_AVAILABLE = 0;
    STORAGESTATE_ARCHIVED = 1;
  }

  // Output. Specify whether the Run is in archived or available mode.
  StorageState storage_state = 16;
}

// Describes the state of a Run.
enum RunState {
  // The Run state is unspecified.
  PIPELINE_STATE_UNSPECIFIED = 0;
  // The Run has been created or resumed, and processing has not yet
  // begun.
  PIPELINE_STATE_QUEUED = 1;
  // The service is preparing to run the pipeline.
  PIPELINE_STATE_PENDING = 2;
  // The Run is in progress.
  PIPELINE_STATE_RUNNING = 3;
  // The Run completed successfully.
  PIPELINE_STATE_SUCCEEDED = 4;
  // The Run failed.
  PIPELINE_STATE_FAILED = 5;
  // The Run is being cancelled. From this state, the Run may only go
  // to either PIPELINE_STATE_SUCCEEDED, PIPELINE_STATE_FAILED or
  // PIPELINE_STATE_CANCELLED.
  PIPELINE_STATE_CANCELLING = 6;
  // The Run has been cancelled.
  PIPELINE_STATE_CANCELLED = 7;
  // The Run has been stopped, and can be resumed.
  PIPELINE_STATE_PAUSED = 8;
}

// The runtime detail of Run.
message RunDetail {
  // The context of the pipeline.
  ml_metadata.Context pipeline_context = 1;

  // The context of the current Run.
  ml_metadata.Context pipeline_run_context = 2;

  // The runtime details of the tasks under the Run.
  repeated PipelineTaskDetail task_details = 3;
}

// The runtime detail of a task execution.
message PipelineTaskDetail {
  // The system generated ID of the task.
  int64 task_id = 1;

  // The id of the parent task if the task is within a component scope.
  // Empty if the task is at the root level.
  int64 parent_task_id = 12;

  // The user specified name of the task that is defined in
  // [Run.spec][].
  string task_name = 2;

  // Task create time.
  google.protobuf.Timestamp create_time = 3;

  // Task start time.
  google.protobuf.Timestamp start_time = 4;

  // Task end time.
  google.protobuf.Timestamp end_time = 5;

  // The detailed execution info.
  PipelineTaskExecutorDetail executor_detail = 6;

  // Specifies state of TaskExecution
  enum TaskState {
    // Unspecified.
    STATE_UNSPECIFIED = 0;
    // Specifies pending state for the task.
    PENDING = 1;
    // Specifies task is being executed.
    RUNNING = 2;
    // Specifies task completed successfully.
    SUCCEEDED = 3;
    // Specifies Task cancel is in pending state.
    CANCEL_PENDING = 4;
    // Specifies task is being cancelled.
    CANCELLING = 5;
    // Specifies task was cancelled.
    CANCELLED = 6;
    // Specifies task failed.
    FAILED = 7;
    // Specifies task was skipped due to cache hit.
    SKIPPED = 8;
    // Specifies that the task was not triggered because the task's trigger
    // policy is not satisfied. The trigger policy is specified in the
    // `condition` field of [Run.pipeline_spec][].
    NOT_TRIGGERED = 9;
  }

  // State of the task.
  TaskState state = 7;

  // The execution metadata of the task.
  ml_metadata.Execution execution = 8;

  // The error that occurred during task execution.
  // Only populated when the task's state is FAILED or CANCELLED.
  Status error = 9;

  // A list of artifact metadata.
  message ArtifactList {
    // A list of artifact metadata.
    repeated ml_metadata.Artifact artifacts = 1;
  }

  // The runtime input artifacts of the task.
  map<string, ArtifactList> inputs = 10;

  // The runtime output artifacts of the task.
  map<string, ArtifactList> outputs = 11;

  // A single record of the task status.
  message PipelineTaskStatus {
    // Update time of this status.
    google.protobuf.Timestamp update_time = 1;

    // The state of the task.
    TaskState state = 2;

    // The error that occurred during the state. May be set when the state is
    // any of the non-final state (PENDING/RUNNING/CANCELLING) or FAILED state.
    // If the state is FAILED, the error here is final and not going to be
    // retried.
    // If the state is a non-final state, the error indicates a system-error
    // being retried.
    Status error = 3;
  }

  // A list of task status. This field keeps a record of task status evolving
  // over time.
  repeated PipelineTaskStatus state_history = 13;
}

// The runtime detail of a PipelineTask executor.
message PipelineTaskExecutorDetail {
  // The detail of a container execution. It contains the job names of the
  // lifecycle of a container execution.
  message ContainerDetail {
    // The name of the [CustomJob][] for the main container execution.
    string main_job = 1;

    // The name of the [CustomJob][] for the pre-caching-check container
    // execution. This job will be available if the
    // [Run.pipeline_spec][] specifies the `pre_caching_check` hook in
    // the lifecycle events.
    string pre_caching_check_job = 2;

    // The names of the previously failed [CustomJob][] for the main container
    // executions. The list includes the all attempts in chronological order.
    repeated string failed_main_jobs = 3;

    // The names of the previously failed [CustomJob][] for the
    // pre-caching-check container executions. This job will be available if the
    // [Run.pipeline_spec][] specifies the `pre_caching_check` hook in
    // the lifecycle events.
    // The list includes the all attempts in chronological order.
    repeated string failed_pre_caching_check_jobs = 4;
  }

  // The detailed info for a custom job executor.
  message CustomJobDetail {
    option deprecated = true;

    // The name of the [CustomJob][].
    string job = 1;
  }

  oneof details {
    // The detailed info for a container executor.
    ContainerDetail container_detail = 1;

    // The detailed info for a custom job executor.
    CustomJobDetail custom_job_detail = 2 [deprecated = true];
  }
}

message RunMetric {
  // Required. The user defined name of the metric. It must between 1 and 63
  // characters long and must conform to the following regular expression:
  // `[a-z]([-a-z0-9]*[a-z0-9])?`.
  string name = 1;

  // Required. The runtime node ID which reports the metric. The node ID can be
  // found in the RunDetail.workflow.Status. Metric with same (node_id, name)
  // are considerd as duplicate. Only the first reporting will be recorded. Max
  // length is 128.
  string node_id = 2;

  oneof value {
    // The number value of the metric.
    double number_value = 3;
  }

  enum Format {
    // Default value if not present.
    UNSPECIFIED = 0;
    // Display value as its raw format.
    RAW = 1;
    // Display value in percentage format.
    PERCENTAGE = 2;
  }
  // The display format of metric.
  Format format = 4;
}

message ReportRunMetricsRequest {
  // Required. The parent run ID of the metric.
  string run_id = 1;

  // List of metrics to report.
  repeated RunMetric metrics = 2;
}

message ReportRunMetricsResponse {
  message ReportRunMetricResult {
    // Output. The name of the metric.
    string metric_name = 1;

    // Output. The ID of the node which reports the metric.
    string metric_node_id = 2;

    enum Status {
      // Default value if not present.
      UNSPECIFIED = 0;
      // Indicates successful reporting.
      OK = 1;
      // Indicates that the payload of the metric is invalid.
      INVALID_ARGUMENT = 2;
      // Indicates that the metric has been reported before.
      DUPLICATE_REPORTING = 3;
      // Indicates that something went wrong in the server.
      INTERNAL_ERROR = 4;
    }
    // Output. The status of the metric reporting.
    Status status = 3;

    // Output. The detailed message of the error of the reporting.
    string message = 4;
  }
  repeated ReportRunMetricResult results = 1;
}

message ReadArtifactRequest {
  // The ID of the run.
  string run_id = 1;
  // The ID of the running node.
  string node_id = 2;
  // The name of the artifact.
  string artifact_name = 3;
}

message ReadArtifactResponse {
  // The bytes of the artifact content.
  bytes data = 1;
}
